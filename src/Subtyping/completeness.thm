Import "scheme".

Theorem tex_nil_o : forall Jo, tex nil Jo -> Jo = nil.
intros. case H1. search. case H2.

Theorem tex_uncons_intro : forall E Jo A B,
	tex (j (subty A B) :: E) Jo -> exists a b Jr, Jo = j (subty a b) :: Jr /\ tex E Jr.
induction on 1. intros. case H1.
	apply exFree_weaken to H2. search.
	case H2. case H3. apply IH to H4. search.

% Theorem tex_insert_single : forall E Jo ji m, nabla x,
% 	wfj (j (ji x) :: tyvar x :: E) -> tex (j (ji m) :: E) Jo -> mono E m ->
% 	tex (j (ji x) :: exvar x :: E) Jo /\ wfj (j (ji x) :: exvar x :: E).
% intros.
% 	W: case H1. W: case W.
% 	W: apply wfjg_insert_exvar_raw to _ _ _ W1 with F = tyvar n1 :: nil,
% 		FxE = x\ tyvar n1 :: exvar x :: E.
% 	apply wfjg_subst_exvar to W2 _ _ with A = n1.
% 	split. backchain tex_insert. search.

Theorem tex_extract_exvarR : forall E F FxE FE Jo a A m, nabla x,
	wfj (j (subty (a x) x) :: FxE x) ->
	append (F x) (exvar x :: E) (FxE x) -> append (F x) E (FE x) ->
	tex (j (subty (a x) x) :: FxE x) (j (subty A m) :: Jo) ->
		mono E m /\ tex (j (subty (a m) m) :: FE m) (j (subty A m) :: Jo).
intros. M: apply append_mem to H2 _.
	T: apply tex_extract to _ _ _ H4 with F = x\ j (subty (a x) x) :: F x.
	apply tex_wft_R to _ T. backchain mono_wft.
		W: case H1. W: apply wfj_remove_exvar_mono to H2 _ _ _.
		A: apply append_subst to H3 with A = m1.
		backchain tex_mono. backchain tex_uncons. backchain mono_weaken_f.
	search.

Theorem tex_extract_exvarR_intro : forall FxE a A m Jo, nabla x,
	wfj (j (subty (a x) x) :: FxE x) -> member (exvar x) (FxE x) ->
	tex (j (subty (a x) x) :: FxE x) (j (subty A m) :: Jo x) ->
	exists F E FE Jr, nabla x,
		append (F x) (exvar x :: E) (FxE x) /\ append (F x) E (FE x) /\ Jo = x\ Jr /\
		mono E m /\ tex (j (subty (a m) m) :: FE m) (j (subty A m) :: Jr)
		/\ wfj (FE m) /\ wfta (FE m) m /\ wfta (FE m) (a m).
intros. apply tex_prune_ex to _ _ H3.
	apply single_append to H2. apply wfj_prune_exvar to H1 _.
	apply append_total_E to H4 with B = Er.
	apply tex_extract_exvarR to H1 H4 _ H3.
	apply wfj_remove_exvar_mono to _ _ H1 _ with F = x\ j (subty (a x) x) :: A1 x.
	W: case H8. W: case W1. search.

Theorem tex_extract_exvarR_insert : forall F E FxE m Jo, nabla x y,
	wfj (j (subty m x) :: FxE m x) -> wfj (FxE x x) ->
	append (F x y) (exvar x :: E) (FxE y x) ->
	tex (j (subty m x) :: FxE m x) (j (subty m m) :: Jo x) ->
	exists Jr, nabla x, tex (j (subty x x) :: FxE x x) (j (subty m m) :: Jr) /\
		Jo = x\ Jr /\ wfj (FxE x x) /\ wfta (FxE x x) x.
intros. A: apply append_total_E to H3 with B = E.
	A: apply append_subst to H3 with A = m. A: apply append_subst to A with A = m.
	W: case H1. apply tex_prune_ex to _ _ H4. unfold. backchain append_mem.
	T: apply tex_extract_exvarR to _ A1 A2 H4.
	A: apply append_subst to A with A = n1.
	A: apply append_subst to H3 with A = n1.
	A: assert append (j (subty n1 n1) :: F n1 n1) (exvar n1 :: E)
		(j (subty n1 n1) :: FxE n1 n1).
	M: apply append_mem to A4 _.
	apply tex_insert to A5 _ _ T1 _ with FE = x\ j (subty x x) :: C x x. search.

Theorem tex_extract_exvarR_insert2 : forall F E FxE a b Jo, nabla x y,
	wfj (j (subty (arrow a b) x) :: FxE (arrow a b) x) -> wfj (FxE x x) ->
	append (F x y) (exvar x :: E) (FxE y x) ->
	tex (j (subty (arrow a b) x) :: FxE (arrow a b) x)
		(j (subty (arrow a b) (arrow a b)) :: Jo x) ->
	exists Exy Jr, nabla x y, Jo = x\ Jr /\
		append (F (arrow x y) (arrow x y)) (exvar y :: exvar x :: E) (Exy x y) /\
		tex (j (subty (arrow x y) (arrow x y)) :: Exy x y)
			(j (subty (arrow a b) (arrow a b)) :: Jr).
intros. W: case H1 (keep). A: apply append_total_E to H3 with B = E.
	A: apply append_subst to H3 with A = (arrow a b).
	A: apply append_subst to A with A = (arrow a b).
	apply tex_prune_ex to _ _ H4. unfold. backchain append_mem.
	T: apply tex_extract_exvarR to H1 A1 A2 H4.
	A: apply append_subst to A with A = arrow n3 n4.
	A: apply append_subst to *A3 with A = arrow n3 n4. permute (n3 n1 n4 n2) A3.
	A: apply append_total_E to A3 with B = exvar n2 :: exvar n1 :: E.
	S: apply split3_alt to _ A3.
	S: apply split3_cons to *S with X = j (subty (arrow n1 n2) (arrow n1 n2)).
	S: apply split3_alt to _ A4 with C = exvar n1 :: E.
	S: apply split3_cons to *S1 with X = j (subty (arrow n1 n2) (arrow n1 n2)).
	M: case T.
	apply tex_insert_two to S1 S _ T1 _ _.
		apply append_mem to A4 _. apply append_mem to A4 _ with X = exvar n1.
		A: apply append_subst to H3 with A = n1.
		W: apply wfj_insert_exvar to A5 A4 _. search.
	search.

Theorem tex_extract_exvarL : forall E F FxE FE Jo a A m, nabla x,
	wfj (j (subty x (a x)) :: FxE x) ->
	append (F x) (exvar x :: E) (FxE x) -> append (F x) E (FE x) ->
	tex (j (subty x (a x)) :: FxE x) (j (subty m A) :: Jo) ->
		mono E m /\ tex (j (subty m (a m)) :: FE m) (j (subty m A) :: Jo).
intros. M: apply append_mem to H2 _.
	T: apply tex_extract to _ _ _ H4 with F = x\ j (subty x (a x)) :: F x.
	apply tex_wft_L to _ T. backchain mono_wft.
		W: case H1. W: apply wfj_remove_exvar_mono to H2 _ _ _.
		A: apply append_subst to H3 with A = m1.
		backchain tex_mono. backchain tex_uncons. backchain mono_weaken_f.
	search.

Theorem tex_extract_exvarL_intro : forall FxE a A m Jo, nabla x,
	wfj (j (subty x (a x)) :: FxE x) -> member (exvar x) (FxE x) ->
	tex (j (subty x (a x)) :: FxE x) (j (subty m A) :: Jo x) ->
	exists F E FE Jr, nabla x,
		append (F x) (exvar x :: E) (FxE x) /\ append (F x) E (FE x) /\ Jo = x\ Jr /\
		mono E m /\ tex (j (subty m (a m)) :: FE m) (j (subty m A) :: Jr)
		/\ wfj (FE m) /\ wfta (FE m) m /\ wfta (FE m) (a m).
intros. apply tex_prune_ex to _ _ H3.
	apply single_append to H2. apply wfj_prune_exvar to H1 _.
	apply append_total_E to H4 with B = Er.
	apply tex_extract_exvarL to H1 H4 _ H3.
	apply wfj_remove_exvar_mono to _ _ H1 _ with F = x\ j (subty x (a x)) :: A1 x.
	case H8. case H10. search.

Theorem tex_extract_exvarL_insert : forall F E FxE m Jo, nabla x y,
	wfj (j (subty x m) :: FxE m x) -> wfj (FxE x x) ->
	append (F x y) (exvar x :: E) (FxE y x) ->
	tex (j (subty x m) :: FxE m x) (j (subty m m) :: Jo x) ->
	exists Jr, nabla x, tex (j (subty x x) :: FxE x x) (j (subty m m) :: Jr) /\
		Jo = x\ Jr /\ wfj (FxE x x) /\ wfta (FxE x x) x.
intros. A: apply append_total_E to H3 with B = E.
	A: apply append_subst to H3 with A = m. A: apply append_subst to A with A = m.
	W: case H1. apply tex_prune_ex to _ _ H4. unfold. backchain append_mem.
	T: apply tex_extract_exvarL to _ A1 A2 H4.
	A: apply append_subst to A with A = n1.
	A: apply append_subst to H3 with A = n1.
	A: assert append (j (subty n1 n1) :: F n1 n1) (exvar n1 :: E)
		(j (subty n1 n1) :: FxE n1 n1).
	M: apply append_mem to A4 _.
	apply tex_insert to A5 _ _ T1 _ with FE = x\ j (subty x x) :: C x x. search.

Theorem tex_extract_exvarL_insert2 : forall F E FxE a b Jo, nabla x y,
	wfj (j (subty x (arrow a b)) :: FxE (arrow a b) x) -> wfj (FxE x x) ->
	append (F x y) (exvar x :: E) (FxE y x) ->
	tex (j (subty x (arrow a b)) :: FxE (arrow a b) x)
		(j (subty (arrow a b) (arrow a b)) :: Jo x) ->
	exists Exy Jr, nabla x y, Jo = x\ Jr /\
		append (F (arrow x y) (arrow x y)) (exvar y :: exvar x :: E) (Exy x y) /\
		tex (j (subty (arrow x y) (arrow x y)) :: Exy x y)
			(j (subty (arrow a b) (arrow a b)) :: Jr).
intros. W: case H1 (keep). A: apply append_total_E to H3 with B = E.
	A: apply append_subst to H3 with A = (arrow a b).
	A: apply append_subst to A with A = (arrow a b).
	apply tex_prune_ex to _ _ H4. unfold. backchain append_mem.
	T: apply tex_extract_exvarL to H1 A1 A2 H4.
	A: apply append_subst to A with A = arrow n3 n4.
	A: apply append_subst to *A3 with A = arrow n3 n4. permute (n3 n1 n4 n2) A3.
	A: apply append_total_E to A3 with B = exvar n2 :: exvar n1 :: E.
	S: apply split3_alt to _ A3.
	S: apply split3_cons to *S with X = j (subty (arrow n1 n2) (arrow n1 n2)).
	S: apply split3_alt to _ A4 with C = exvar n1 :: E.
	S: apply split3_cons to *S1 with X = j (subty (arrow n1 n2) (arrow n1 n2)).
	M: case T.
	apply tex_insert_two to S1 S _ T1 _ _.
		apply append_mem to A4 _. apply append_mem to A4 _ with X = exvar n1.
		A: apply append_subst to H3 with A = n1.
		W: apply wfj_insert_exvar to A5 A4 _. search.
	search.


Theorem tex_wft_chk : forall E Jo X A x a, wft Jo A ->
	tex (j (check X A) :: E) (j (check x a) :: Jo) -> A = a.
induction on 2. intros. case H2. search.
	apply wft_prune to _. case H3. case H4. apply IH to _ H5. search.

Theorem tex_extract_exvarChk : forall E F FxE FE X Xo m Jo, nabla x,
	wfj (j (check (X x) x) :: FxE x) ->
	append (F x) (exvar x :: E) (FxE x) -> append (F x) E (FE x) ->
	tex (j (check (X x) x) :: FxE x) (j (check Xo m) :: Jo) ->
		mono E m /\ tex (j (check (X m) m) :: FE m) (j (check Xo m) :: Jo).
intros. apply tex_extract to _ _ _ H4 with F = x\ j (check (X x) x) :: F x.
	apply tex_wft_chk to _ H5. backchain mono_wft.
		apply append_subst to H3 with A = m1.
		W: case H1.
		apply wfj_remove_exvar_mono to H2 _ _ _.
		backchain tex_mono. backchain tex_uncons. backchain mono_weaken_f.
	search.

Theorem tex_extract_exvarChk_intro : forall FxE X Xo m Jo, nabla x,
	wfj (j (check (X x) x) :: FxE x) -> member (exvar x) (FxE x) ->
	tex (j (check (X x) x) :: FxE x) (j (check Xo m) :: Jo x) ->
	exists F E FE Jr, nabla x,
		append (F x) (exvar x :: E) (FxE x) /\ append (F x) E (FE x) /\ Jo = x\ Jr /\
		mono E m /\ tex (j (check (X m) m) :: FE m) (j (check Xo m) :: Jr) /\ wfj (FE m).
intros. apply tex_prune_ex to _ _ H3.
	apply single_append to H2. apply wfj_prune_exvar to H1 _.
	apply append_total_E to H4 with B = Er.
	apply tex_extract_exvarChk to H1 H4 _ H3.
	case H1. apply wfj_remove_exvar_mono to H4 H5 _ _. search.


Theorem tex_arrow_matchL : forall E Jo A1 A2 B a b,
	tex (j (subty (arrow A1 A2) B) :: E) (j (subty a b) :: Jo) ->
	exists a1 a2, a = arrow a1 a2.
induction on 1. intros. case H1. search. case H2. case H3. apply IH to H4. search.
Theorem tex_arrow_matchR : forall E Jo A B1 B2 a b,
	tex (j (subty A (arrow B1 B2)) :: E) (j (subty a b) :: Jo) ->
	exists b1 b2, b = arrow b1 b2.
induction on 1. intros. case H1. search. case H2. case H3. apply IH to H4. search.
Theorem tex_arrow_matchChk : forall E Jo A1 A2 a X x,
	tex (j (check X (arrow A1 A2)) :: E) (j (check x a) :: Jo) ->
	exists a1 a2, a = arrow a1 a2.
induction on 1. intros. case H1. search. case H2. case H3. apply IH to H4. search.

Theorem tex_all_matchL : forall E Jo A B a b,
	tex (j (subty (all A) B) :: E) (j (subty a b) :: Jo) -> exists a1, a = all a1.
induction on 1. intros. case H1. search. case H2. case H3. apply IH to H4. search.
Theorem tex_all_matchR : forall E Jo A B a b,
	tex (j (subty A (all B)) :: E) (j (subty a b) :: Jo) -> exists b1, b = all b1.
induction on 1. intros. case H1. search. case H2. case H3. apply IH to H4. search.
Theorem tex_all_matchChk : forall E Jo A a X x,
	tex (j (check X (all A)) :: E) (j (check x a) :: Jo) ->
	exists a0, a = all a0.
induction on 1. intros. case H1. search. case H2. case H3. apply IH to H4. search.
Theorem tex_all_matchChk_inv : forall E Jo A a X x,
	tex (j (check X A) :: E) (j (check x (all a)) :: Jo) ->
	exists A0, A = all A0.
induction on 1. intros. case H1. search.
	case H2. case H3. apply IH to H4. case H9. search. case H6.

Theorem tex_wftm_check : forall E Jo X A x a, wftm Jo X ->
	tex (j (check X A) :: E) (j (check x a) :: Jo) -> X = x.
induction on 2. intros. case H2. search.
	apply wftm_prune to _. case H3. case H4. apply IH to _ H5. search.

Theorem tex_unit_check : forall E Jo X A a,
	tex (j (check X A) :: E) (j (check unit a) :: Jo) -> X = unit.
induction on 1. intros. case H1. search.
	case H2. case H3. apply IH to H4. case H9. search.

Theorem tex_wft_check : forall E Jo X A x a, wft Jo A ->
	tex (j (check X A) :: E) (j (check x a) :: Jo) -> A = a.
induction on 2. intros. case H2. search.
	apply wft_prune to _. case H3. case H4. apply IH to _ H5. search.

Theorem tex_chkallR_shape_inv : forall E Jo X Xo A a, nabla (x : ty),
	tex (j (check X (all A)) :: E) (j (check Xo (all a)) :: Jo) ->
	tex (j (check X (A x)) :: E) (j (check Xo (a x)) :: Jo).
induction on 1. intros. case H1 (keep).
	apply exFree_weaken to H2. apply exFree_j to H3 with J = check Xo (a n1). search.
	case H2. case H3. apply IH to H4. search.

Theorem tex_chkB_shape_inv : forall E Jo X Xo A B, nabla (x : ty),
	tex (j (check X A) :: E) (j (check Xo B) :: Jo) ->
	notAll_ B -> notLam_ Xo ->
	tex (j (inferC X (r\ subty r A)) :: E) (j (inferC Xo (r\ subty r B)) :: Jo) /\
		notAll_ A /\ notLam_ X.
induction on 1. intros. case H1.
	apply exFree_weaken to H4.
		apply exFree_j to H5 with J = inferC Xo (r\subty r B). search.
	case H4. case H5. apply IH to H6 _ _. split. search.
		case H12. unfold. intros. case H15. backchain H14.
		case H13. unfold. intros. case H15. backchain H14.

Theorem tex_chkB_shape_inv_ : forall E Jo X Xo A B, nabla (x : ty),
	tex (j (check X A) :: E) (j (check Xo B) :: Jo) -> notAll_ B -> notLam_ Xo ->
	tex (j (inferC X (r\ subty r A)) :: E) (j (inferC Xo (r\ subty r B)) :: Jo) /\
		notAll_ A /\ notLam_ X.
induction on 1. intros. case H1.
	apply exFree_weaken to H4.
		apply exFree_j to H5 with J = inferC Xo (r\subty r B). search.
	case H4. case H5. apply IH to H6 _ _.
		N: assert notAll_ (A n1). unfold. intros Eq. case Eq. F: case H12. apply F to _.
		N: assert notLam_ (X n1). unfold. intros Eq. case Eq. F: case H13. apply F to _.
	search.

Theorem tex_chkArrR_shape_allL : forall E Jo X Xo A a b, nabla (x : ty),
	tex (j (check X (all A)) :: E) (j (check Xo (arrow a b)) :: Jo) -> false.
induction on 1. intros. case H1.
	case H2. case H3. apply IH to H4.

Theorem tex_chkLam_shape_inv : forall E Jo X Xo A B a b,
	tex (j (check X (arrow A B)) :: E) (j (check (lam Xo) (arrow a b)) :: Jo) ->
	wfta E A -> wfj E ->
	exists Xl, nabla x, X = lam Xl /\
		tex (j (check (Xl x) B) :: of x A :: E) (j (check (Xo x) b) :: of x a :: Jo).
induction on 1. intros. case H1.
	apply exFree_weaken to H4. apply exFree_of to H5 with A = a.
		apply exFree_j to H6 with J = check (Xo n1) b. search.
	case H4. case H5.
		W: apply wfj_remove_exvar_mono to _ _ H3 _.
		W: apply wfta_strenthen_exvar_mono to H10 H9 _ _.
		apply IH to H6 _ _. case H11. search.

Theorem tex_remove_exvar_of : forall F E FE FxE A m, nabla x t,
	append (F t x) (E t) (FE t x) -> append (F t x) (exvar x :: E t) (FxE t x) ->
	member (of t A) (FE t m) -> wfj (FxE t x) ->
		exists Ao, nabla t x, member (of t (Ao x)) (FxE t x) /\ Ao m = A.
induction on 1. intros. case H1. case H2. search.
	case H2. case H3. case H7. case H9. case H4. search.
		apply wfj_rev to H4. apply IH to H5 _ _ H8. search.

Theorem tex_inferX_shape_inv : forall E Jo X ji jo Ao, nabla x,
	tex (j (inferC (X x) (ji x)) :: E x) (j (inferC x (jo x)) :: Jo x) ->
	wfj (E x) -> member (of x Ao) (Jo x) ->
	exists Ax, nabla x, X = x\ x /\ member (of x Ax) (E x) /\
		tex (j (ji x Ax) :: E x) (j (jo x Ao) :: Jo x).
induction on 1. intros. case H1.
	apply exFree_weaken to H4. apply exFree_j to H5 with J = jo n1 Ao. search.
	case H4. case H5. W: apply wfj_remove_exvar_mono to _ _ H2 _.
		apply mono_prune_tm to H8.
		apply wfj_member_prune to H3.
		apply IH to H6 _ _ with Ao = Fr1. case H11.
		apply tex_remove_exvar_of to H10 H9 H12 _. search.

Theorem tex_inferAnno_shape_inv : forall E Jo X Xo ji jo Ao,
	tex (j (inferC X ji) :: E) (j (inferC (anno Xo Ao) jo) :: Jo) ->
	exists Xi Ai, X = anno Xi Ai /\
		tex (j (check Xi Ai) :: j (ji Ai) :: E) (j (check Xo Ao) :: j (jo Ao) :: Jo).
induction on 1. intros. case H1.
	apply exFree_weaken to H2. apply exFree_j to H3 with J = jo Ao.
		apply exFree_j to H4 with J = check Xo Ao. search.
	case H2. case H3. apply IH to H4. case H9. search.

Theorem tex_inferUnit_shape_inv : forall E Jo ji jo X,
	tex (j (inferC X ji) :: E) (j (inferC unit jo) :: Jo) ->
	X = unit /\ tex (j (ji i) :: E) (j (jo i) :: Jo).
induction on 1. intros. case H1.
	apply exFree_weaken to H2. apply exFree_j to H3 with J = jo i. search.
	case H2. case H3. apply IH to H4. case H9. search.

Theorem tex_checkTop_shape_inv : forall E Jo A X Xo,
	tex (j (check X A) :: E) (j (check Xo top) :: Jo) ->
	tex E Jo.
induction on 1. intros. case H1.
	apply exFree_weaken to H2. apply exFree_j to H3 with J = check Xo top. search.
	case H2. case H3. apply IH to H4. search.

Theorem tex_inferLam_shape_inv : forall E Jo X Xo ji jo M1 M2,
	tex (j (inferC X ji) :: E) (j (inferC (lam Xo) jo) :: Jo) ->
	wfj E -> mono Jo (arrow M1 M2) ->
	exists Xi, nabla t, X = lam Xi /\
		tex (j (check (Xi t) M2) :: of t M1 :: j (ji (arrow M1 M2)) :: E)
			(j (check (Xo t) M2) :: of t M1 :: j (jo (arrow M1 M2)) :: Jo).
induction on 1. intros. case H1.
	apply exFree_weaken to H4. apply exFree_j to H5 with J = jo (arrow M1 M2).
		apply exFree_of to H6 with A = M1.
		apply exFree_j to H7 with J = check (Xo n1) M2. search.
	case H4. case H5. apply mono_prune to H3.
		W: apply wfj_remove_exvar_mono to H9 H10 _ _.
		apply IH to H6 _ H3. case H11. search.

Theorem tex_inferApp_shape_inv : forall E Jo X X1 X2 ji jo,
	tex (j (inferC X ji) :: E) (j (inferC (app X1 X2) jo) :: Jo) ->
	exists Xi Xj, X = app Xi Xj /\ tex (j (inferC Xi (r\ inferAppC r Xj ji)) :: E)
		(j (inferC X1 (r\ inferAppC r X2 jo)) :: Jo).
induction on 1. intros. case H1.
	apply exFree_weaken to H2.
		apply exFree_j to H3 with J = inferC X1 (r\inferAppC r X2 jo). search.
	case H2. case H3. apply IH to H4. case H9. search.

Theorem tex_inferAppAll_shape_inv : forall E Jo A Ao X Xo ji jo m,
	tex (j (inferAppC A X ji) :: E) (j (inferAppC (all Ao) Xo jo) :: Jo) -> mono Jo m ->
	exists Ai, A = (all Ai) /\ tex (j (inferAppC (Ai m) X ji) :: E)
		(j (inferAppC (Ao m) Xo jo) :: Jo).
induction on 1. intros. case H1.
	apply exFree_weaken to H3.
		apply exFree_j to H4 with J = inferAppC (Ao m) Xo jo. search.
	apply mono_prune to H2. case H3. case H4.
		apply IH to H5 H2. case H10. search. case H7.

Theorem tex_infAppBot_shape : forall E Xi Xo ji jo Jo,
	tex (j (inferAppC bot Xi ji) :: E)
		(j (inferAppC bot Xo jo) :: Jo) ->
	tex (j (ji bot) :: E) (j (jo bot) :: Jo).
induction on 1. intros. case H1.
	apply exFree_weaken to H2. apply exFree_j to H3 with J = jo bot. search.
	case H2. case H3. apply IH to H4. search.

Theorem tex_infAppArr_shape : forall E Xi Xo A1 A2 B1 B2 ji jo Jo,
	tex (j (inferAppC (arrow A1 A2) Xi ji) :: E)
		(j (inferAppC (arrow B1 B2) Xo jo) :: Jo) ->
	tex (j (check Xi A1) :: j (ji A2) :: E) (j (check Xo B1) :: j (jo B2) :: Jo).
induction on 1. intros. case H1.
	apply exFree_weaken to H2. apply exFree_j to H3 with J = jo B2.
		apply exFree_j to H4 with J = check Xo B1. search.
	case H2. case H3. apply IH to H4. search.

Theorem tex_infAppArrR_shape_arr_bot : forall E Jo X Xo A B ji jo,
	tex (j (inferAppC (arrow A B) X ji) :: E) (j (inferAppC bot Xo jo) :: Jo) ->
	false.
induction on 1. intros. case H1.
	case H2. case H3. apply IH to H4.

Theorem tex_infAppArrR_shape_all_bot : forall E Jo X Xo A ji jo,
	tex (j (inferAppC (all A) X ji) :: E) (j (inferAppC bot Xo jo) :: Jo) ->
	false.
induction on 1. intros. case H1.
	case H2. case H3. apply IH to H4.

Theorem tex_infAppArrR_shape_all : forall E Jo X Xo A a b ji jo,
	tex (j (inferAppC (all A) X ji) :: E) (j (inferAppC (arrow a b) Xo jo) :: Jo) ->
	false.
induction on 1. intros. case H1.
	case H2. case H3. apply IH to H4.

Theorem tex_subArr_shape : forall E A1 A2 B1 B2 a1 a2 b1 b2 Jo,
	tex (j (subty (arrow A1 A2) (arrow B1 B2)) :: E)
		(j (subty (arrow a1 a2) (arrow b1 b2)) :: Jo) ->
	tex (j (subty B1 A1) :: j (subty A2 B2) :: E)
		(j (subty b1 a1) :: j (subty a2 b2) :: Jo).
induction on 1. intros. case H1.
	apply exFree_weaken to H2. apply exFree_j to H3 with J = subty a2 b2.
		apply exFree_j to H4 with J = subty b1 a1. search.
	case H2. case H3. apply IH to H4. search.


Theorem tex_insert_xy_intro : forall F E FxE FE Jo m1 m2, nabla x,
	append (F x) (exvar x :: E) (FxE x) -> append (F x) E (FE x) -> wfj (FxE x) ->
		tex (FE (arrow m1 m2)) Jo -> mono E (arrow m1 m2) ->
		exists FxyE, nabla y z,
			append (F (arrow y z)) (exvar z :: exvar y :: E) (FxyE y z) /\
			wfj (FxyE y z) /\ tex (FxyE y z) Jo.
intros. case H5.
	E: apply wfj_weaken to H1 _. E: case E.
	A: apply append_subst_x to H2 with A = x\ arrow x n2.
	A: apply append_total_E to A with B = exvar n2 :: exvar n1 :: E.
	E: apply wfj_insert_exvar to H1 A1 _.
	A: apply wfj_remove_exvar_intro to A1 _ _ with A = m2.
		backchain wfta_weaken_ex. backchain mono_wfta.
	A: apply append_subst to A with x = n2, A = m2.
	T: apply tex_insert to A3 A5 _ H4 _.
	T: apply tex_insert to A1 A2 _ T _.
		backchain mono_weaken_f with E = exvar n1 :: nil.
	search.

Theorem wftm_subst : forall E T X m, wftm E (T X) -> wfta E m -> wftm E (T m).
induction on 1. intros. case H1.
	case H3. search.
	case H3. search.
	case H3. W: apply wfta_weaken_of to H2 with A = A.
		apply IH to H5 W with T = x\ T1 x n1. search.
	case H3. apply IH to H4 _ with T = T1. apply IH to H5 _ with T = T2. search.
	case H3. apply IH to H4 _ with T = T1.
		apply wfta_subst to H5 _ with T = T2. search.

Theorem tex_insert_xy_intro_chkLamArr : forall F E FxE FE Jo m1 m2 X, nabla x t,
	append (F x) (exvar x :: E) (FxE x) -> append (F x) E (FE x) ->
		wfj (j (check (lam (X (arrow m1 m2))) x) :: FxE x) ->
		tex (j (check (X (arrow m1 m2) t) m2) :: of t m1 :: FE (arrow m1 m2)) (Jo t) ->
		mono E (arrow m1 m2) ->
		exists FxyE, nabla y z t,
			append (F (arrow y z)) (exvar z :: exvar y :: E) (FxyE y z) /\
			wfj (FxyE y z) /\ wfj (j (check (X (arrow y z) t) z) :: of t y :: FxyE y z) /\
			tex (j (check (X (arrow y z) t) z) :: of t y :: FxyE y z) (Jo t).
intros. M: case H5 (keep). permute (n2 n4) H4.
	W: case H3.
	E: apply wfj_weaken to H1 _. E: case E.
	Ax: apply append_subst_x to H2 with A = x\ arrow x n3.
	A: apply append_subst to Ax with x = n2, A = n1. permute (n2 n3) A.
	A: apply append_total_E to A with B = exvar n2 :: exvar n1 :: E.
	E: apply wfj_insert_exvar to H1 A1 _.
	A: apply wfj_remove_exvar_intro to A1 _ _ with A = m2.
		backchain wfta_weaken_ex. backchain mono_wfta.
	A: apply append_subst to A with x = n2, A = m2.
	A: assert append (j (check (X (arrow n1 m2) n4) m2) :: of n4 n1 :: F (arrow n1 m2))
		(exvar n1 :: E) (j (check (X (arrow n1 m2) n4) m2) :: of n4 n1 :: FE1 n1 m2).
	A: assert append (j (check (X (arrow n1 m2) n4) m2) :: of n4 n1 :: F (arrow n1 m2)) E
		(j (check (X (arrow n1 m2) n4) m2) :: of n4 n1 :: FE (arrow n1 m2)).
	T: apply tex_insert to A6 A7 _ H4 _.
		apply append_mem to A3 _. assert member (exvar n1) (of n4 n1 :: FE1 n1 m2).
		apply append_assoc_inv to _ A3 with C = E.
		M: apply mono_weaken_f to _ M1 with EF = of n4 n1 :: FE1 n1 m2.
		W: apply mono_wfta to M2.
		W: case W1.
		W: apply wftm_insert_exvar to H1 _ _ W1. permute (n2 n3) W4.
		W: apply wftm_subst to W4 _ with T = x\ lam (X (arrow x m2)), m = n1.
			apply append_mem to A1 _ with X = exvar n1. search.
		W: apply mono_wfta to M1. W: apply wfta_weaken_ex to W6.
		W: apply wftm_strenthen_exvar to A2 A1 W5 W7.
		W: apply wftm_anyA to W8 with A = n1.
		search.
	clear A6. clear A7.
	A: assert append (j (check (X (arrow n1 n2) n4) n2) :: of n4 n1 :: F (arrow n1 n2))
		(exvar n2 :: exvar n1 :: E)
		(j (check (X (arrow n1 n2) n4) n2) :: of n4 n1 :: C n1 n2).
	A: assert append (j (check (X (arrow n1 n2) n4) n2) :: of n4 n1 :: F (arrow n1 n2))
		(exvar n1 :: E) (j (check (X (arrow n1 n2) n4) n2) :: of n4 n1 :: FE1 n1 n2).
		M: apply append_mem to A1 _ with X = exvar n1.
		M: apply append_mem to A1 _ with X = exvar n2.
		W: case W1. W: apply wftm_insert_exvar to H1 A1 _ W1.
		W: apply wftm_subst to W3 _ with T = x\ lam (X (arrow x m2)), m = n1.
		W: apply wftm_subst to W4 _ with T = x\ lam (X (arrow n1 x)), m = n2.
		W: apply wftm_anyA to W5 with A = n1, x = n4.
		M: apply append_mem to A1 _ with X = exvar n2.
	T: apply tex_insert to A6 A7 _ T _.
		backchain mono_weaken_ex.
	search.


Theorem tex_infApp_wft : forall E Jo A Xi ji B Xo jo,
	tex (j (inferAppC A Xi ji) :: E) (j (inferAppC B Xo jo) :: Jo) -> wft Jo A -> A = B.
induction on 1. intros. case H1. search.
	apply wft_prune to H2. case H3. case H4. apply IH to H5 H2. search.

Theorem tex_allL_shape_inv : forall E Jo A B a b m,
	tex (j (subty (all A) B) :: E) (j (subty (all a) b) :: Jo) ->
	wfj E -> wft E m -> notAll_ b ->
	tex (j (subty (A m) B) :: E) (j (subty (a m) b) :: Jo) /\ notAll_ B.
induction on 1. intros. case H1.
	apply exFree_weaken to H5. apply exFree_j to H6 with J = subty (a m) b. search.
	case H5. case H6. M: apply append_mem to H10 _. apply wft_no_ex to H3 _ _.
		E: apply wfj_remove_exvar_mono to H10 H11 _ _.
		W: apply wft_strenthen_exvar to H11 H10 _ _ with A = m1. backchain mono_wft.
		T: apply IH to H7 _ W _.
		split. search.
		case T1. unfold. intros. case H13. apply H12 to _.

Theorem tex_allR_shape_inv : forall E Jo A B a b, nabla (x : ty),
	tex (j (subty (A x) (all B)) :: E) (j (subty (a x) (all b)) :: Jo) ->
	tex (j (subty (A x) (B x)) :: E) (j (subty (a x) (b x)) :: Jo).
induction on 1. intros. case H1.
	apply exFree_weaken to H2. apply exFree_j to H3 with J = subty (a n1) (b n1). search.
	case H2. case H3. apply append_prune to H7. apply append_prune_AB to H8.
		apply mono_prune to H6. apply IH to H4. search.
	case H2. apply append_prune to H7.

Theorem tex_mono_x : forall F E FE Jo m, nabla x,
	append (F x) E (FE x) -> tex (FE m) Jo ->
	wfj (FE m) -> mono E m -> mono Jo m.
intros. apply append_subst to H1 with A = m.
	apply mono_weaken_f to H5 H4. backchain tex_mono.

Theorem tex_nilR_judge : forall E, wfj E -> tex E nil -> judge E.
induction on 1. intros. case H1. search.
	apply tex_uncons_ty to H2.
	apply tex_uncons_ex to H2. apply IH to H3 _. search.
	apply tex_uncons_of to H2.
	apply tex_uncons_shape to H2.

Theorem tex_Ljudge : forall E Jo jo,
	wfj E -> tex E (j jo :: Jo) ->
	(forall jr Er, wfj (j jr :: Er) -> tex (j jr :: Er) (j jo :: Jo) ->
		judge (j jr :: Er)) -> judge E.
induction on 1. intros. case H1. search.
	apply tex_uncons_ty to H2.
	apply tex_uncons_ex to H2. apply IH to H4 _ _. search.
	apply tex_uncons_of to H2.
	backchain H3.

Theorem tex_L_tyvar_judge : forall E Jo, nabla x,
	wfr1 (E x) -> wfj (E x) -> tex (E x) (tyvar x :: Jo) ->
	(forall Er, nabla x,
		wfr1 (tyvar x :: Er) -> wfj (tyvar x :: Er) ->
		tex (tyvar x :: Er) (tyvar x :: Jo) ->
		judge (tyvar x :: Er)
	) -> judge (E x).
induction on 2. intros. case H2. search.
	apply tex_uncons_ty to H3.
	backchain H4.
	apply tex_uncons_ex to H3.
		case H1. applys IH. search.
	apply tex_no_ex to _ _ H3.
	apply tex_uncons_of to H3.
	case H6.
		apply tex_match_subty to H3. apply tex_match_check to H3.
		apply tex_match_inferC to H3 _. apply tex_match_inferAppC to H3 _.

Theorem tex_L_of_judge : forall E Jo a, nabla x,
	wfr1 (E x) -> wfj (E x) -> tex (E x) (of x a :: Jo) ->
	(forall Er A, nabla x,
		wfr1 (of x A :: Er) -> wfj (of x A :: Er) ->
		tex (of x A :: Er) (of x a :: Jo) ->
		judge (of x A :: Er)
	) -> judge (E x).
induction on 2. intros. case H2. search.
	apply tex_uncons_ty to H3.
	apply tex_uncons_ex to H3. case H1. applys IH H5. search.
	apply tex_uncons_of to H3.
	backchain H4.
	case H6.
		apply tex_match_subty to H3. apply tex_match_check to H3.
		apply tex_match_inferC to H3 _. apply tex_match_inferAppC to H3 _.

Theorem tex_L_subty_judge : forall E Jo a b,
	wfr1 E -> wfj E -> tex E (j (subty a b) :: Jo) ->
	(forall A B Er,
		wfr1 (j (subty A B) :: Er) -> wfj (j (subty A B) :: Er) ->
		tex (j (subty A B) :: Er) (j (subty a b) :: Jo) ->
		judge (j (subty A B) :: Er)) -> judge E.
induction on 2. intros. case H2. search.
	apply tex_uncons_ty to H3.
	apply tex_uncons_ex to H3.
		case H1. applys IH. search.
	apply tex_uncons_of to H3.
	case H6. backchain H4.
		apply tex_match_check to H3.
		apply tex_match_inferC to H3 _. apply tex_match_inferAppC to H3 _.

Theorem tex_L_check_judge : forall E Jo x a,
	wfr1 E -> wfj E -> tex E (j (check x a) :: Jo) ->
	(forall X A Er,
		wfr1 (j (check X A) :: Er) -> wfj (j (check X A) :: Er) ->
		tex (j (check X A) :: Er) (j (check x a) :: Jo) ->
		judge (j (check X A) :: Er)) -> judge E.
induction on 2. intros. case H2. search.
	apply tex_uncons_ty to H3.
	apply tex_uncons_ex to H3.
		case H1. applys IH. search.
	apply tex_uncons_of to H3.
	case H6.
		apply tex_match_subty to H3. backchain H4.
		apply tex_match_inferC to H3 _. apply tex_match_inferAppC to H3 _.

Theorem tex_L_inferC_judge : forall E Jo x a,
	wfr1 E -> wfj E -> tex E (j (inferC x a) :: Jo) ->
	(forall X A Er,
		wfr1 (j (inferC X A) :: Er) -> wfj (j (inferC X A) :: Er) ->
		tex (j (inferC X A) :: Er) (j (inferC x a) :: Jo) ->
		judge (j (inferC X A) :: Er)) -> judge E.
induction on 2. intros. case H2. search.
	apply tex_uncons_ty to H3.
	apply tex_uncons_ex to H3.
		case H1. applys IH. search.
	apply tex_uncons_of to H3.
	case H6.
		apply tex_match_subty to H3. apply tex_match_check to H3.
		backchain H4. apply tex_match_inferAppC to H3 _.

Theorem tex_L_inferAppC_judge : forall E Jo a x c,
	wfr1 E -> wfj E -> tex E (j (inferAppC a x c) :: Jo) ->
	(forall A X C Er,
		wfr1 (j (inferAppC A X C) :: Er) -> wfj (j (inferAppC A X C) :: Er) ->
		tex (j (inferAppC A X C) :: Er) (j (inferAppC a x c) :: Jo) ->
		judge (j (inferAppC A X C) :: Er)) -> judge E.
induction on 2. intros. case H2. search.
	apply tex_uncons_ty to H3.
	apply tex_uncons_ex to H3.
		case H1. applys IH. search.
	apply tex_uncons_of to H3.
	case H6.
		apply tex_match_subty to H3. apply tex_match_check to H3.
		apply tex_match_inferC to H3 _. backchain H4.

Theorem tex_wft_inv : forall E Jo A, tex E Jo -> wfj E -> wft Jo A -> wft E A.
induction on 1. intros. case H1. search.
	apply wft_prune to H3.
	W: apply wfj_remove_exvar_mono to _ _ _ _.
	apply IH to H6 _ _. apply wft_weaken_exvar_fresh to H5 H4 _ H9. search.

Theorem completeness : forall E Jo, wfr1 E -> wfj E -> tex E Jo -> dcl Jo -> judge E.
induction on 4. intros. case H4 (keep).
	% nil
	backchain tex_nilR_judge.
	% E, a
	backchain tex_L_tyvar_judge. intros r w t.
		WR: case r. W: case w. T: apply tex_uncons_ty to t.
		J: applys IH. search.
	% E, x:A
	backchain tex_L_of_judge. intros r w t.
		WR: case r. W: case w. T: apply tex_uncons_of to t.
		J: applys IH. search.
	% i <: i
	backchain tex_L_subty_judge. intros r w t.
		WR: case r. W2: case w. T: apply tex_uncons to t.
		W: case W1.
		W: case W (keep).
			% A = 1
			W: case W1 (keep).
				% B = 1
				applys IH. search.
				% B = top/bot (impossible)
				applys tex_wft_R. applys tex_wft_R.
				% B = a
				apply tex_mem_tyvar to _ _ W3. applys tex_wft_R t.
				% B = ^a
				T: apply tex_extract_exvarR_intro to _ W3 _.
					W: apply wfj_remove_exvar_mono to T1 T2 _ _.
					T: apply tex_uncons to T4.
					WR: applys wfr1_solve_exvar T1.
					applys IH.
					search.
				% B = A1 -> B1 or \forall
				apply tex_arrow_matchR to t. apply tex_all_matchR to t.
			% A = top/bot (impossible)
			applys tex_wft_L. applys tex_wft_L.
			% A = a
			apply tex_mem_tyvar to _ _ W3. apply tex_wft_L to _ t.
			% A = ^a
			W: case W1 (keep).
				% B = 1
				T: apply tex_extract_exvarL_intro to _ W3 _.
					W: apply wfj_remove_exvar_mono to T1 T2 _ _.
					T: apply tex_uncons to T4.
					WR: applys wfr1_solve_exvar T1.
					applys IH.
					search.
				% B = top/bot (impossible)
				applys tex_wft_R t. applys tex_wft_R t.
				% B = b
				apply tex_mem_tyvar to _ _ W4. apply tex_wft_R to _ t.
				% B = a
				apply wfj_tyvar_exvar to W2 _ _.
				% B = ^b
				S: apply two_split3 to W3 W4 _. S: case S.
					apply wfj_nabla_prune_exvars to S _.
						A: apply split3_alt_inv to S. A: case A. apply append_prune_AB to A.
						T: apply tex_extract_exvarL_intro to _ W3 _.
						apply wfj_mid_exvar_det to *T1 A1 _.
						A: apply append_assoc_inv to A T2. M: apply append_mem to A _.
						W: apply wfj_remove_exvar_nabla to A1 T2 _ _ with A = n2.
						T: apply tex_extract_exvarR_insert to _ _ A3 T4.
						T: apply tex_uncons to T1.
						WR: applys wfr1_solve_exvar A1 with m = n2.
						applys IH T10 H5. search.
					apply wfj_nabla_prune_exvars to S _.
						A: apply split3_alt_inv to S. A: case A. apply append_prune_AB to A.
						T: apply tex_extract_exvarR_intro to _ W4 _.
						apply wfj_mid_exvar_det to *T1 A1 _.
						A: apply append_assoc_inv to A T2. M: apply append_mem to A _.
						W: apply wfj_remove_exvar_nabla to A1 T2 _ _ with A = n1.
						T: apply tex_extract_exvarL_insert to _ _ A3 T4.
						T: apply tex_uncons to T1.
						WR: applys wfr1_solve_exvar A1 with m = n1.
						applys IH T10 H5. search.
				% B = ^a
				applys IH. search.
				% B = A1 -> B1 or \forall
				apply tex_arrow_matchR to t. apply tex_all_matchR to t.
			% A = A1 -> B1 or \forall
			apply tex_arrow_matchL to t. apply tex_all_matchL to t.
	% A <: top
	backchain tex_L_subty_judge. intros r w t. T: apply tex_uncons to t.
		W2: case w. W: case W1. WR: case r.
		W: case W1 (keep).
			% B = 1
			apply tex_wft_R to _ t.
			% B = top
			applys IH. search.
			% B = bot
			apply tex_wft_R to _ t.
			% B = b
			applys tex_mem_tyvar. applys tex_wft_R t.
			% B = ^b
			applys tex_prune_ex t.
				T: applys tex_extract_exvarR_intro.
				T: applys tex_uncons T4.
				WR: applys wfr1_solve_exvar T1 with m = top.
				applys IH.
				search.
			% B = A1 -> B1 or \forall
			apply tex_arrow_matchR to t. apply tex_all_matchR to t.
	% bot <: B
	backchain tex_L_subty_judge. intros r w t. T: apply tex_uncons to t.
		W2: case w. W: case W1. WR: case r.
		W: case W (keep).
			% A = 1
			apply tex_wft_L to _ t.
			% A = top
			apply tex_wft_L to _ t.
			% A = bot
			applys IH. search.
			% B = b
			applys tex_mem_tyvar. applys tex_wft_L t.
			% B = ^b
			applys tex_prune_ex t.
				T: applys tex_extract_exvarL_intro.
				T: applys tex_uncons T4.
				WR: applys wfr1_solve_exvar T1 with m = bot.
				applys IH.
				search.
			% B = A1 -> B1 or \forall
			apply tex_arrow_matchL to t. apply tex_all_matchL to t.
	% a <: a
	backchain tex_L_subty_judge. intros r w t. T: apply tex_uncons to t.
		W2: case w. W: case W1. WR: case r.
		W: case W (keep).
			% A = 1
			apply tex_wft_L to _ t.
			% A = top/bot (impossible)
			applys tex_wft_L t. applys tex_wft_L t.
			% A = b
			apply tex_mem_tyvar to _ _ W3. apply tex_wft_L to _ t.
			% A = a
			M: apply tex_mem_tyvar to _ _ W3. W: case W1 (keep).
				% B = 1
				apply tex_wft_R to _ t.
				% B = top/bot (impossible)
				applys tex_wft_R t. applys tex_wft_R t.
				% B = b
				apply tex_mem_tyvar to _ _ W4. apply tex_wft_R to _ t.
				% B = a
				applys IH. search.
				% B = ^b
				T: apply tex_extract_exvarR_intro to _ W4 _.
					T: apply tex_uncons to T4.
					WR: applys wfr1_solve_exvar T1 with m = n1.
						backchain mono_is_monoA.
					applys IH.
					M: case T3. A: apply single_append to M1.
					S: apply split3_alt to _ T1 with C = tyvar n1 :: B1 n1.
					apply wfj_nabla_prune_exvar_tyvar to S _.
					S: apply split3_alt to A T2.
					search.
				% B = ^a
				apply wfj_tyvar_exvar to W2 _ _.
				% B = A1 -> B1 or \forall
				apply tex_arrow_matchR to t. apply tex_all_matchR to t.
			% A = ^b
			T: apply tex_extract_exvarL_intro to _ W3 _. W: case W1 (keep).
				% B = i
				apply tex_wft_R to _ t.
				% B = top/bot (impossible)
				applys tex_wft_R t. applys tex_wft_R t.
				% B = c
				apply tex_mem_tyvar to _ _ W4. apply tex_wft_R to _ t.
				% B = a
				T: apply tex_uncons to T4.
					WR: applys wfr1_solve_exvar T1 with m = n1.
						backchain mono_is_monoA.
					applys IH.
					M: case T3. A: apply single_append to M.
					S: apply split3_alt to _ T1 with C = tyvar n1 :: B1 n1.
					apply wfj_nabla_prune_exvar_tyvar to S _.
					S: apply split3_alt to A T2.
					search.
				% B = b
				apply wfj_tyvar_exvar to W2 _ _.
				% B = ^c : both exvar, false
				R1: case WR.
				applys r1sub_prune_exvar_xy R1.
				% B = ^a
				apply tex_prune_ex to _ _ t with x = n1.
				% B = ^b
				T: apply tex_uncons to t. applys IH T8 H6. search.
				% B = A1 -> B1 or \forall
				apply tex_arrow_matchR to t. apply tex_all_matchR to t.
			% A = ^a
			apply tex_prune_ex to _ _ t with x = n1.
			% A = A1 -> B1 or \forall
			apply tex_arrow_matchL to t. apply tex_all_matchL to t.
	% A1 -> A2 <: B1 -> B2
	backchain tex_L_subty_judge. intros r w t. T: apply tex_uncons to t.
		W2: case w. W: case W1. WR: case r.
		W: case W (keep).
			% A = 1
			apply tex_wft_L to _ t.
			% B = top/bot (impossible)
			applys tex_wft_L t. applys tex_wft_L t.
			% A = a
			apply tex_mem_tyvar to _ _ W3. apply tex_wft_L to _ t.
			% A = ^a
			W: case W1 (keep).
				% B = 1
				apply tex_wft_R to _ t.
				% B = top/bot (impossible)
				applys tex_wft_R t. applys tex_wft_R t.
				% B = b
				apply tex_mem_tyvar to _ _ W4. apply tex_wft_R to _ t.
				% B = a
				apply wfj_tyvar_exvar to _ W4 W3.
				% B = ^b : both exvar, false
				R1: case WR.
				applys r1sub_prune_exvar_xy R1.
				% B = ^a : both ^a, false
				R1: case WR.
				applys r1sub_prune_exvar_l R1.
				% B = A3 -> B3
				D: apply dcl_sound to _ H4. backchain tex_wfj.
					D: case D. apply tex_prune_ex to _ _ t.
					R1: case WR.
					applys r1sub_prune_exvar_l R1.
					T: apply tex_extract_exvarL_intro to _ _ t.
					T: apply tex_insert_xy_intro to _ _ _ T4 T3 with
						FE = x\ j (subty x (arrow Ar1 Ar2)) :: FE x,
						FxE = x\ j (subty x (arrow Ar1 Ar2)) :: Er x.
					A: case T8. W: case T9. W: case W7. W: case W7. W: case W8.
					T: apply tex_subArr_shape to T10.
					W: apply wfta_weaken_j to W8 with J = subty n2 Ar2.
					W: apply wfta_weaken_j to W7 with J = subty n2 Ar2.
					J: applys IH T8 H5.
						A: assert append (j (subty n1 (arrow Ar1 Ar2)) :: F n1)
							(exvar n1 :: E2) (j (subty n1 (arrow Ar1 Ar2)) :: Er n1).
						R: applys wfr1_insert_xy A1.
						R: case R. R: case R.
						M: applys append_mem A. M: applys append_mem A with X = exvar n1.
						R: case R. applys mono_prune_exvar R.
						M: case R. M: case M2.
						M: applys mono_weaken_f M2 with E = j (subty n3 Ar2) :: nil.
						search 10.
					search.
				% B = \forall a. A3
				apply tex_all_matchR to t.
			% A = A3 -> B3
			W: case W1 (keep).
				% B = 1
				apply tex_wft_R to _ t.
				% B = top/bot (impossible)
				applys tex_wft_R t. applys tex_wft_R t.
				% B = b
				apply tex_mem_tyvar to _ _ W5. apply tex_wft_R to _ t.
				% B = ^a
				D: apply dcl_sound to _ H4. backchain tex_wfj.
					D: case D. apply tex_prune_ex to _ _ t.
					R1: case WR.
					applys r1sub_prune_exvar_r R1.
					T: apply tex_extract_exvarR_intro to _ _ t.
					T: apply tex_insert_xy_intro to _ _ _ T4 T3 with
						FE = x\ j (subty (arrow Ar1 Ar2) x) :: FE x,
						FxE = x\ j (subty (arrow Ar1 Ar2) x) :: Er x.
					A: case T8. W: case T9. W: case W7. W: case W7. W: case W8.
					T: apply tex_subArr_shape to T10.
					W: apply wfta_weaken_j to W8 with J = subty Ar2 n2.
					W: apply wfta_weaken_j to W7 with J = subty Ar2 n2.
					J: applys IH T8 H5.
						A: assert append (j (subty (arrow Ar1 Ar2) n1) :: F n1)
							(exvar n1 :: E2) (j (subty (arrow Ar1 Ar2) n1) :: Er n1).
						R: applys wfr1_insert_xy A1.
						R: case R. R: case R.
						M: applys append_mem A. M: applys append_mem A with X = exvar n1.
						R: case R.
						M: case R.
						M: applys mono_weaken_f M2 with E = j (subty Ar2 n3) :: nil.
						search 10.
						M: case R. applys mono_prune_exvar M2.
					search.
				% B = A4 -> B4
				T: apply tex_subArr_shape to t.
					W: case W. W: case W1.
					W: apply wfta_weaken_j to W with J = subty B3 B4.
					W: apply wfta_weaken_j to W1 with J = subty B3 B4.
					J: applys IH H5.
						R: case WR. R: case R.
						% mono <: schemeA
							M: case R. S: case R1. M: case S.
							M: applys mono_weaken_f M with E = j (subty B3 B4) :: nil.
							M: applys monoA_weaken_j M2 with J = subty B3 B4.
							search.
						% schemeA <: scheme
							M: case R. M: case R1.
							M: case M. M: case M1.
							M: applys mono_weaken_f M with E = j (subty B3 B4) :: nil.
							M: applys monoA_weaken_j M1 with J = subty B3 B4.
							search.
					search.
				% B = \forall a. A4
				apply tex_all_matchR to t.
			% A = \forall a. A3
			apply tex_all_matchL to t.
	% \forall a. A1 <: B1
	backchain tex_L_subty_judge. intros r w t. T: apply tex_uncons to t.
		W2: case w. W: case W1.
		W: case W (keep).
			% A = 1
			apply tex_wft_L to _ t.
			% A = top/bot (impossible)
			applys tex_wft_L t. applys tex_wft_L t.
			% A = a
			apply tex_mem_tyvar to _ _ W3. apply tex_wft_L to _ t.
			% A = ^a
			T: apply tex_extract_intro to t _ _. A: case T1. A: case T2.
				T: apply tex_uncons to T4. W: apply wfj_remove_exvar_mono to A A1 _ _.
				M: apply tex_mono_x to A1 T1 _ T3.
				T: apply tex_wft_L to _ T4. backchain mono_wft. case M.
			% A = A2 -> B2
			apply tex_arrow_matchL to t.
			% A = \forall a. A2
			M: apply tex_mono_inv to T _ H6. W: apply mono_wft to M.
				T: apply tex_allL_shape_inv to t _ _ _.
				W: apply wfta_open_exvar to _ W. W: apply wfta_weaken_ex to W1.
				T: apply tex_insert to _ _ _ T1 M with
					F = x\ j (subty (A2 x) B1) :: nil, FE = x\ j (subty (A2 x) B1) :: Er,
					FxE = x\ j (subty (A2 x) B1) :: exvar x :: Er.
				J: applys IH T3 H7.
					R: case r. R: case R. R: case R. case R.
					S: applys schemeA_open_exvar R2.
					S: applys scheme_weaken_ex R.
					search.
				search.
	% A1 <: \forall a. B1
	backchain tex_L_subty_judge. intros r w t. T: apply tex_uncons to t.
		W2: case w. W: case W1.
		W: case W1 (keep).
			% B = 1
			apply tex_wft_R to _ t.
			% B = top/bot (impossible)
			applys tex_wft_R t. applys tex_wft_R t.
			% B = a
			apply tex_mem_tyvar to _ _ W3. apply tex_wft_R to _ t.
			% B = ^a
			T: apply tex_extract_intro to t _ _. A: case T1. A: case T2.
				T: apply tex_uncons to T4. W: apply wfj_remove_exvar_mono to A A1 _ _.
				M: apply tex_mono_x to A1 T1 _ T3.
				T: apply tex_wft_R to _ T4. backchain mono_wft. case M.
			% B = A2 -> B2
			apply tex_arrow_matchR to t.
			% A = \forall a. A2
			T: apply tex_allR_shape_inv to t. T: apply tex_J_ty to T1 _.
				W: apply wfta_weaken_ty to W.
				J: applys IH H5.
					R: case r. R: case R. R: case R.
						S: case R2. case S.
							M: applys mono_weaken_f R with E = tyvar n1 :: nil.
							search.
						S: case R. case S.
							S: applys schemeA_weaken_ty R2.
							search.
				search.

	% rank-1 completeness does not involve typing system
	backchain tex_L_inferC_judge. intros r w t. R: case r. R: case R.
	backchain tex_L_inferC_judge. intros r w t. R: case r. R: case R.
	backchain tex_L_check_judge. intros r w t. R: case r. R: case R.
	backchain tex_L_inferC_judge. intros r w t. R: case r. R: case R.
	backchain tex_L_check_judge. intros r w t. R: case r. R: case R.
	backchain tex_L_check_judge. intros r w t. R: case r. R: case R.
	backchain tex_L_check_judge. intros r w t. R: case r. R: case R.
	backchain tex_L_inferC_judge. intros r w t. R: case r. R: case R.
	backchain tex_L_inferC_judge. intros r w t. R: case r. R: case R.
	backchain tex_L_check_judge. intros r w t. R: case r. R: case R.
	backchain tex_L_inferAppC_judge. intros r w t. R: case r. R: case R.
	backchain tex_L_inferAppC_judge. intros r w t. R: case r. R: case R.
	backchain tex_L_inferAppC_judge. intros r w t. R: case r. R: case R.


%%%%%%%%%%%%%%%%%%%%%% Corollaries of completeness %%%%%%%%%%%%%%%%%%%%%%
Theorem env_dcl : forall E, env E -> dcl E.
induction on 1. intros. case H1. search.
	apply IH to H2. search.
	apply IH to H2. search.

Theorem exFree_env : forall E, env E -> exFree E.
induction on 1. intros. case H1. backchain exFree_nil.
	apply IH to H2. backchain exFree_tyvar.
	apply IH to H2. backchain exFree_of.


Theorem completeness_sub_wft : forall E A B Jo Ao Bo,
	wfj (j (subty A B) :: E) -> tex (j (subty A B) :: E) (j (subty Ao Bo) :: Jo) ->
	wfr1 (j (subty A B) :: E) ->
	sub Jo Ao Bo -> env Jo -> judge (j (subty A B) :: E).
intros. D: apply env_dcl to H5.
	J: applys completeness H2.
		backchain dcl_complete.
			backchain tex_wfj. backchain exFree_j. backchain exFree_env.
		D: apply dcl_sound to _ D. backchain env_wfj. search.
	search.


