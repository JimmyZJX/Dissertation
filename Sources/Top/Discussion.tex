
\section{Discussion}

% \subsection{Design of Various Backtracing Patterns}

\subsection{A Complete Algorithm Under Monotype Guessing Restrictions}

The incompleteness of the algorithm is mainly due to incomplete guesses
for existential variable instantiations when dealing with subtyping.
If the declarative system did not treat the bottom and top types
as monotypes in the first place,
the algorithm would not need to guess those types.
Formally, if monotypes are defined as follows,
$$\text{Monotypes}\qquad \tau' \quad  ::= \quad 1 \mid a \mid \tau_1\to \tau_2$$
then unification based on equality regains completeness between monotypes.
Incomplete examples mentioned before like $\al \le \bt$ can be safely treated as $\al = \bt$,
because of the lemma:
\begin{lemma}[Subtyping between Monotypes is Equality]~\\
    If $\Psi \vdash \tau'_1 \le \tau'_2$, then $\tau'_1 = \tau'_2$.
\end{lemma}

On the meantime, algorithmic subtyping rules 12 and 13, and typing rules 27 and 37
are removed from the algorithm under the monotype restriction,
since these rules solves existential variables to $\top$ or $\bot$.
As a result, both soundness and completeness are successfully mechanized.
It is not a surprising finding,
given that the algorithm reduce judgments in a similar way
compared with the one in the previous chapter.
However, it still reveals the fact that
if we do not try to guess any subtyping relation,
the algorithm should remain simple and complete.


\subsection{Lazy Substitution and Non-terminating Loops}\label{subsec:lazy_subst}

One major source of incompleteness comes from rule 20 and 21,
where two different existential variables are compared.
A natural idea is to delay the solving procedure until all the corresponding
constraints are collected.
Constraint collection can be implemented by the following new worklist definition,
where the existential variables also come with a set of upper bounds
and a set of lower bounds. Both of the bounds consist of algorithmic mono-types.

\begin{gather*}
    \begin{aligned}
        \text{Algorithmic worklist}\qquad&\Gm &::=&\quad \cdot \mid \Gm, a \mid \Gm, \overline{\tau_A} \le \al \le \overline{\tau_A} \mid \Gm \Vdash \jg
    \end{aligned}
\end{gather*}

In presence of the bound collections, the algorithm behaves slightly differently
on variable solving rules.
For example, rules 20 and 21 add the corresponding existential variable
as part of a bound rather than performing a global substitution.

\begin{gather*}
    \begin{aligned}
\Gm[\al][L \le \bt \le U] \Vdash \al \le \bt &\rrule{20'}
    \Gm[\al][L \cup \{\al\} \le \bt \le U]\\
\Gm[\al][L \le \bt \le U] \Vdash \bt \le \al &\rrule{21'}
    \Gm[\al][L \le \bt \le U \cup \{\al\}]\\
    \end{aligned}
\end{gather*}

The change of existential variable declaration also result in the change of
the algorithmic rule on existential variable garbage collection.
When $\al$ is to be recycled, we need to propagate the subtyping check to
the bounds: any type that is a subtype of $\al$ should be subtype of
any super type of $\al$, according to the transitivity of subtyping.

\begin{gather*}
    \begin{aligned}
\Gm, \{l_i\}^n \le \al \le \{u_j\}^m &\rrule{2'}
    \Gm \Vdash_{1 \le i \le n, 1 \le j \le m} l_i \le u_j\\
    \end{aligned}
\end{gather*}

Luckily, such check is sufficient. In other words,
we can always find a proper solution for $\al$ if any lower bound
is subtype of any upper bound.

This new approach fixes the incompleteness caused by rules 20 and 21,
however, the algorithm might loop forever due to the
(new version of) instantiation rules 14 and 15.
For example, the following derivation results in infinite instantiations:

\begin{gather*}
    \begin{aligned}
     & \al, \bt \Vdash \al \le 1 \to \bt \Vdash \bt \le 1 \to \al\\
\rto~& \al, \bt[1], \bt[2], \{\} \le \bt \le \{\bt[1] \to \bt[2]\}
        \Vdash \al \le 1 \to \bt \Vdash \bt[1] \to \bt[2] \le 1 \to \al\\
\rto~& \cdots\\
\rto~& \al, \{1\} \le \bt[1] \le \{\}, \{\} \le \bt[2] \le \{\al\},
        \{\} \le \bt \le \{\bt[1] \to \bt[2]\}
        \Vdash \al \le 1 \to \bt\\
\rto~& \cdots\\
    \end{aligned}
\end{gather*}

% \jimmy{Not sure whether this discussion is valueable;
% in fact the example is hard to demonstrate the infinite loop
% (not straightforward to understand)}
