%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\chapter{Higher-Rank Polymorphism with Object-Oriented Subtyping}
\label{chap:Top}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 


\section{Introduction and Motivation}


\section{Declarative System}

\begin{figure}[t]
    \begin{gather*}
    \begin{aligned}
        \text{Type variables}\qquad&a, b\\
        \text{Types}\qquad&A, B, C &::=&\quad 1 \mid \top \mid \bot \mid a \mid \all A \mid A\to B\\
        \text{Monotypes}\qquad&\tau &::=&\quad 1 \mid \top \mid \bot \mid a \mid \tau_1\to \tau_2\\
        \text{Expressions}\qquad&e &::=&\quad x \mid () \mid \lam e \mid e_1~e_2 \mid (e:A)\\
        \text{Context}\qquad&\Psi &::=&\quad \cdot \mid \Psi, a \mid \Psi, x:A
    \end{aligned}
    \end{gather*}
\Description{Declarative Syntax}
\caption{Declarative Syntax}\label{fig:top_decl_syntax}
\end{figure}

\paragraph{Syntax}
The syntax of the declarative system, shown in Figure~\ref{fig:top_decl_syntax},
is similar to the previous systems by having
a primitive type $1$, type variables $a$,
polymorphic types $\all A$ and function types $A \to B$.
Additionally, top and bottom types are introduced to the type system.
The top type, $\top$, is the super type of any type,
i.e. any type is more general than $\top$
and thus can be considered as an instance of type $\top$.
In typical object-oriented programming languages, the \texttt{Object} class,
as the base class of any class, is the $\top$ type.
In contrast, the bottom type, $\bot$, is dual to $\top$.
An instance of $\bot$ can be casted to a value of any type, which is usually impossible,
except when that is a \texttt{null pointer} value (\texttt{(void *)} in C++, for example).
Another practical use for bottom types is exception.
The type $\text{Exception} \to \bot$ given to the \texttt{raise}
function may pass type checkers natually.
The type $\text{Exception} \to \all a$ is also a reasonable choice,
which in fact reveals that $\bot$ behaves almost identical to $\all a$.
In the theoretical point of view, both of them are considered ``falsity''.

The well-formedness for the system is standard and almost identical to the previous systems,
therefore we omit the formal definitions.


\begin{figure}[t]
    \framebox{$\Psi \vdash A \le B$}
    \begin{gather*}
    \inferrule*[right=$\mathtt{{\le}Var}$]
    {a\in\Psi}{\Psi\vdash a\le a}
    \qquad
    \inferrule*[right=$\mathtt{{\le}Unit}$]
    {~}{\Psi \vdash 1 \le 1}
    \qquad
    \inferrule*[right=$\mathtt{{\le}{\to}}$]
    {\Psi \vdash B_1 \le A_1 \quad \Psi \vdash A_2 \le B_2}
    {\Psi\vdash A_1\to A_2 \le B_1\to B_2}
    \\
    \inferrule*[right=$\mathtt{{\le}\forall L}$]
    {\Psi\vdash \tau \quad \Psi\vdash [\tau/a] A \le B}
    {\Psi\vdash \all A \le B}
    \qquad
    \inferrule*[right=$\mathtt{{\le}\forall R}$]
    {\Psi, b\vdash A\le B}
    {\Psi\vdash A \le \all[b]B}
    \\
    \pmb{
    \inferrule*[right=$\mathtt{{\le}Top}$]
    {~}
    {A \le \top}
    }
    \qquad
    \pmb{
    \inferrule*[right=$\mathtt{{\le}Bot}$]
    {~}
    {\bot \le A}
    }
    \end{gather*}
\Description{Declarative Subtyping}
\caption{Declarative Subtyping}\label{fig:top_decl_subtyping}
\end{figure}

\paragraph{Declarative Subtyping}
Our declarative subtyping extends the polymorphic subtyping relation
originally proposed by Odersky and L\"aufer~\cite{odersky1996putting}
by adding rules $\mathtt{{\le}Top}$ and $\mathtt{{\le}Bot}$,
defining the properties of the $\top$ and $\bot$ types, respectively.
Although the new rules seem quite simple,
they may increase the uncertainty on polymorphic instantiations.
For example, the subtyping judgement
\[\all a \to a \le \bot \to \top\]
accepts any well-formed instantiation on the polymorphic type $\all a \to a$.




\begin{figure}[t]
    \begin{tabular}{rl}
        \framebox{$\Psi \vdash e \Lto A$} & $e$ checks against input type $A$.\\[0.5mm]
        \framebox{$\Psi \vdash e \To A$} & $e$ synthesizes output type $A$.\\[0.5mm]
        \framebox{$\Psi \vdash \appInf{A}{e}{C}$} & Applying a function of type $A$ to $e$ synthesizes type $C$.
    \end{tabular}
    \begin{gather*}
    \inferrule*[right=$\mathtt{DeclVar}$]
        {(x:A)\in\Psi}{\Psi\vdash x\To A}
    \qquad
    \inferrule*[right=$\mathtt{DeclSub}$]
    %e \neq \lam e' \quad B \neq \all B' \quad 
        {\Psi\vdash e\To A \quad \Psi\vdash A\le B}
        {\Psi \vdash e\Lto B}
    \\
    \inferrule*[right=$\mathtt{DeclAnno}$]
        {\Psi \vdash A \quad \Psi\vdash e\Lto A}
        {\Psi\vdash (e:A)\To A}
    \qquad
    \inferrule*[right=$\mathtt{Decl1I{\To}}$]
        {~}{\Psi\vdash () \To 1}
    \\
    \inferrule*[right=$\mathtt{Decl1I}$]
        {~}{\Psi\vdash () \Lto 1}
    \qquad
    \inferrule*[right=$\mathtt{Decl\top}$]
        {\Psi \vdash e}
        {\Psi\vdash e \Lto \top}
    \\
    \inferrule*[right=$\mathtt{Decl\forall I}$]
        {\Psi,a \vdash e \Lto A}
        {\Psi\vdash e\Lto \all A}
    \qquad
    \inferrule*[right=$\mathtt{Decl\forall App}$]
        {\Psi \vdash \tau \quad \Psi\vdash \appInf{[\tau/a]A}{e}{C} }
        {\Psi\vdash \appInf{\all A}{e}{C}}
    \\
    \inferrule*[right=$\mathtt{Decl{\to}I}$]
        {\Psi,x:A \vdash e\Lto B}
        {\Psi\vdash \lam e \Lto A \to B}
    \qquad
    \inferrule*[right=$\mathtt{Decl{\to}I{\To}}$]
        {\Psi\vdash \sigma\to\tau \quad \Psi,x:\sigma \vdash e\Lto \tau}
        {\Psi\vdash \lam e \To \sigma\to\tau}
    \\
    \inferrule*[right=$\mathtt{Decl{\to} E}$]
        {\Psi\vdash e_1\To A \quad \Psi\vdash \appInf{A}{e_2}{C}}
        {\Psi\vdash e_1~e_2 \To C}
    \qquad
    \inferrule*[right=$\mathtt{Decl{\to}App}$]
        {\Psi\vdash e \Lto A}
        {\Psi\vdash \appInf{A \to C}{e}{C}}
    \end{gather*}
\Description{Declarative Typing}
\caption{Declarative Typing}\label{fig:top_decl_typing}
\end{figure}

\paragraph{Declarative Typing}



$$\begin{aligned}
\text{Type variables}\qquad&a, b\\
\text{Existential variables}\qquad&\al, \bt\\[3mm]
\text{Types}\qquad&A, B, C &::=&\quad 1 \mid \top \mid \bot \mid a \mid \forall x. A \mid A\to B \mid \al\\
\text{Declarative Monotypes}\qquad&\tau &::=&\quad 1 \mid \top \mid \bot \mid a \mid \tau_1\to \tau_2\\
% \text{Algorithmic Monotypes}\qquad & l, u &::=&\quad 1 \mid \top \mid \bot \mid a \mid \tau_1\to \tau_2 \mid \al\\
% \text{Bound Collection}\qquad & L, U &::=&\quad \{\overline l\}\\
% \text{Potential function types}\qquad&\sigma &::=&\quad \top \mid \bot \mid \sigma_1\to \sigma_2 \mid \al\\
\text{Context}\qquad&\Psi &::=&\quad \cdot \mid \Psi, a
\\[3mm]
% \text{Algorithmic judgement chain}\qquad&\jg &::=&\quad A \le B\\[3mm]
\text{Algorithmic worklist}\qquad&\Gm &::=&\quad \cdot \mid \Gm, a \mid \Gm, \al \mid \Gm \Vdash A \le B\\[3mm]
% \text{Terms}\qquad&e&::=&\quad x \mid () \mid \lam{e} \mid e_1~e_2 \mid (e:A)
\end{aligned}$$







\section{Algorithmic System}

\setcounter{algRuleCounter}{0}

\begin{figure}[t]
    \noindent\framebox{$\Gm\rto \Gm'$} $\Gm$ reduces to $\Gm'$.
    \begin{gather*}
    \begin{aligned}
    \Gm, a &\algrule \Gm\\
    \Gm, \al &\algrule \Gm\\
    \Gm, x:A &\algrule \Gm\\
    % \\
    % \pmb{
    % (\Gm, L \le \al \le U)} &\algrule \Gm \Vdash l_1 \le u_1 \Vdash \ldots \Vdash l_n \le u_m
    % 	\quad \color{blue} \text{Add $nm$ judgments}\\
    \\
    \Gm \Vdash 1\le 1 &\algrule \Gm\\
    \Gm \Vdash a\le a &\algrule \Gm\\
    \Gm[\al] \Vdash \al\le \al &\algrule \Gm\\
    \\
    \Gm \Vdash A_1\to A_2 \le B_1\to B_2 &\algrule \Gm \Vdash A_2 \le B_2 \Vdash B_1\le A_1\\
    \Gm \Vdash \forall a. A\le B &\algrule \Gm, \al \Vdash [\al/a]A\le B\\
    \Gm \Vdash A\le \forall b. B &\algrule \Gm,b \Vdash A\le B\\
    \\
    \Gm \Vdash A\le \top &\algrule \Gm\\
    \Gm \Vdash \bot \le B &\algrule \Gm\\
    \\
    % \multispan2{\text{\jimmy{These 2 rules introduce non-determinicity}}}\\
    \Gm[\al] \Vdash A \le \al &\algrule \{\al := \top\}~\Gm[\al]\\
    \Gm[\al] \Vdash \al \le A &\algrule \{\al := \bot\}~\Gm[\al]\\
    \\
    \Gm[\al] \Vdash \al \le A\to B &\algrule
    \{\al := \al[1] \to \al[2]\}~(\Gm[\al] \Vdash \al \le A\to B)\\
    &\qquad\qquad \text{when } \al\notin FV(A \to B)\\
    \Gm[\al] \Vdash A\to B \le \al &\algrule
    \{\al := \al[1] \to \al[2]\}~(\Gm[\al] \Vdash A\to B \le \al)\\
    %\Gm[\al[1], \al[2], L \cup \{\al[1] \to \al[2]\} \le \al \le U] \Vdash A \to B \le \al[1] \to \al[2]\\
    &\qquad\qquad \text{when } \al\notin  FV(A \to B)\\
    \\
    \Gm[a][\bt] \Vdash a \le \bt &\algrule \{\bt := a\}~\Gm[a][\bt]\\
    \Gm[a][\bt] \Vdash \bt \le a &\algrule \{\bt := a\}~\Gm[a][\bt]\\
    \Gm[\bt] \Vdash 1 \le \bt &\algrule \{\bt := 1\}~\Gm[\bt]\\
    \Gm[\bt] \Vdash \bt \le 1 &\algrule \{\bt := 1\}~\Gm[\bt]\\
    \\
    \Gm[\al][\bt] \Vdash \al \le \bt &\algrule \{\bt := \al\}~\Gm[\al][\bt]\\
    \Gm[\al][\bt] \Vdash \bt \le \al &\algrule \{\bt := \al\}~\Gm[\al][\bt]\\
    \end{aligned}
    \end{gather*}
\Description{Algorithmic Subtyping}
\caption{Algorithmic Subtyping}\label{fig:top_alg_subtyping}
\end{figure}


\begin{figure}[t]
\noindent\framebox{$\Gm\rto \Gm'$} $\Gm$ reduces to $\Gm'$ (continued).
\begin{gather*}
\begin{aligned}
    \Gm \Vdash e \Lto B &\algrule \Gm \Vdash e\To_a a\le B \quad
    \text{when } e \neq \lam e' \text{ and } B \neq \all B'\\
    \Gm \Vdash e \Lto \top &\algrule \Gm\\
    \Gm \Vdash e\Lto \all A &\algrule \Gm,a \Vdash e\Lto A\\
    \Gm \Vdash \lam e \Lto A\to B &\algrule \Gm, x:A  \Vdash e \Lto B\\
    \Gm[\al] \Vdash \lam e \Lto \al &\algrule [\al[1]\to \al[2] / \al](\Gm[\al[1],\al[2]], x:\al[1] \Vdash e \Lto \al[2])
    % \quad\text{\jimmy{Additional}}
    \\[3mm]
    \Gm \Vdash x\To_a \jg &\algrule \Gm \Vdash [A/a] \jg \quad \text{when } (x:A)\in \Gm\\
    \Gm \Vdash (e:A)\To_a \jg &\algrule \Gm \Vdash [A/a]\jg \Vdash e \Lto A\\
    \Gm \Vdash ()\To_a \jg &\algrule \Gm \Vdash [1/a]\jg\\
    \Gm \Vdash \lam e \To_a \jg &\algrule
    \Gm,\al,\bt \Vdash [\al\to\bt/a]\jg, x:\al \Vdash e\Lto \bt\\
    \Gm \Vdash e_1\ e_2 \To_a \jg &\algrule \Gm \Vdash e_1\To_b (\appInfAlg{b}{e_2})
    \\[3mm]
    \Gm \Vdash \appInfAlg{\all A}{e} &\algrule \Gm,\al \Vdash \appInfAlg{[\al/a]A}{e}\\
    \Gm \Vdash \appInfAlg{A\to C}{e} &\algrule \Gm \Vdash [C/a]\jg \Vdash e \Lto A\\
    \Gm[\al] \Vdash \appInfAlg{\al}{e} &\algrule
    [\al[1]\to\al[2]/\al](\Gm[\al[1], \al[2]] \Vdash \appInfAlg{\al[1]\to\al[2]}{e})
\end{aligned}
\end{gather*}
\Description{Algorithmic Subtyping}
\caption{Algorithmic Subtyping}\label{fig:top_alg_subtyping}
\end{figure}


\section{Metatheory}

\subsection{Soundness}

\subsection{Partial Completeness of Subtyping: Rank-1 Restriction}

\subsection{Termination}

\subsection{Formalization in the Abella Proof Assistant}

