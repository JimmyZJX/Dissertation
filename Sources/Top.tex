%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\chapter{Higher-Rank Polymorphism with Object-Oriented Subtyping}
\label{chap:Top}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 


\section{Introduction and Motivation}


\section{Declarative System}

\begin{figure}[t]
    \begin{gather*}
    \begin{aligned}
        \text{Type variables}\qquad&a, b\\
        \text{Types}\qquad&A, B, C &::=&\quad 1 \mid \top \mid \bot \mid a \mid \all A \mid A\to B\\
        \text{Monotypes}\qquad&\tau &::=&\quad 1 \mid \top \mid \bot \mid a \mid \tau_1\to \tau_2\\
        \text{Expressions}\qquad&e &::=&\quad x \mid () \mid \lam e \mid e_1~e_2 \mid (e:A)\\
        \text{Context}\qquad&\Psi &::=&\quad \cdot \mid \Psi, a \mid \Psi, x:A
    \end{aligned}
    \end{gather*}
\Description{Declarative Syntax}
\caption{Declarative Syntax}\label{fig:top_decl_syntax}
\end{figure}

\paragraph{Syntax}
The syntax of the declarative system, shown in Figure~\ref{fig:top_decl_syntax},
is similar to the previous systems by having
a primitive type $1$, type variables $a$,
polymorphic types $\all A$ and function types $A \to B$.
Additionally, top and bottom types are introduced to the type system.
The top type, $\top$, is the super type of any type,
i.e. any type is more general than $\top$
and thus can be considered as an instance of type $\top$.
In typical object-oriented programming languages, the \texttt{Object} class,
as the base class of any class, is the $\top$ type.
In contrast, the bottom type, $\bot$, is dual to $\top$.
An instance of $\bot$ can be casted to a value of any type, which is usually impossible,
except when that is a \texttt{null pointer} value (\texttt{(void *)} in C++, for example).
Another practical use for bottom types is exception.
The type $\text{Exception} \to \bot$ given to the \texttt{raise}
function may pass type checkers natually.
The type $\text{Exception} \to \all a$ is also a reasonable choice,
which in fact reveals that $\bot$ behaves almost identical to $\all a$.
In the theoretical point of view, both of them are considered ``falsity''.
\jimmy{The discussion might be moved to intro/motivation part}

The well-formedness for the system is standard and almost identical to the previous systems,
therefore we omit the formal definitions.


\begin{figure}[t]
    \framebox{$\Psi \vdash A \le B$}
    \begin{gather*}
    \inferrule*[right=$\mathtt{{\le}Var}$]
    {a\in\Psi}{\Psi\vdash a\le a}
    \qquad
    \inferrule*[right=$\mathtt{{\le}Unit}$]
    {~}{\Psi \vdash 1 \le 1}
    \qquad
    \inferrule*[right=$\mathtt{{\le}{\to}}$]
    {\Psi \vdash B_1 \le A_1 \quad \Psi \vdash A_2 \le B_2}
    {\Psi\vdash A_1\to A_2 \le B_1\to B_2}
    \\
    \inferrule*[right=$\mathtt{{\le}\forall L}$]
    {\Psi\vdash \tau \quad \Psi\vdash [\tau/a] A \le B}
    {\Psi\vdash \all A \le B}
    \qquad
    \inferrule*[right=$\mathtt{{\le}\forall R}$]
    {\Psi, b\vdash A\le B}
    {\Psi\vdash A \le \all[b]B}
    \\
    \pmb{
    \inferrule*[right=$\mathtt{{\le}Top}$]
    {~}
    {A \le \top}
    }
    \qquad
    \pmb{
    \inferrule*[right=$\mathtt{{\le}Bot}$]
    {~}
    {\bot \le A}
    }
    \end{gather*}
\Description{Declarative Subtyping}
\caption{Declarative Subtyping}\label{fig:top_decl_subtyping}
\end{figure}

\paragraph{Declarative Subtyping}
Shown in Figure~\ref{fig:top_decl_subtyping},
the declarative subtyping extends the polymorphic subtyping relation
originally proposed by Odersky and L\"aufer~\cite{odersky1996putting}
by adding rules $\mathtt{{\le}Top}$ and $\mathtt{{\le}Bot}$,
defining the properties of the $\top$ and $\bot$ types, respectively.
Although the new rules seem quite simple,
they may increase the uncertainty on polymorphic instantiations.
For example, the subtyping judgement
\[\all a \to a \le \bot \to \top\]
accepts any well-formed instantiation on the polymorphic type $\all a \to a$.


\begin{figure}[t]
    \begin{tabular}{rl}
        \framebox{$\Psi \vdash e \Lto A$} & $e$ checks against input type $A$.\\[0.5mm]
        \framebox{$\Psi \vdash e \To A$} & $e$ synthesizes output type $A$.\\[0.5mm]
        \framebox{$\Psi \vdash \appInf{A}{e}{C}$} & Applying a function of type $A$ to $e$ synthesizes type $C$.
    \end{tabular}
    \begin{gather*}
    \inferrule*[right=$\mathtt{DeclVar}$]
        {(x:A)\in\Psi}{\Psi\vdash x\To A}
    \qquad
    \inferrule*[right=$\mathtt{DeclSub}$]
    %e \neq \lam e' \quad B \neq \all B' \quad 
        {\Psi\vdash e\To A \quad \Psi\vdash A\le B}
        {\Psi \vdash e\Lto B}
    \\
    \inferrule*[right=$\mathtt{DeclAnno}$]
        {\Psi \vdash A \quad \Psi\vdash e\Lto A}
        {\Psi\vdash (e:A)\To A}
    \qquad
    \inferrule*[right=$\mathtt{Decl1I{\To}}$]
        {~}{\Psi\vdash () \To 1}
    \\
    \inferrule*[right=$\mathtt{Decl1I}$]
        {~}{\Psi\vdash () \Lto 1}
    \qquad
    \inferrule*[right=$\mathtt{Decl\top}$]
        {\Psi \vdash e}
        {\Psi\vdash e \Lto \top}
    \qquad
    \inferrule*[right=$\mathtt{Decl{\bot}App}$]
        {\Psi\vdash e}
        {\Psi\vdash \appInf{\bot}{e}{\bot}}
    \\
    \inferrule*[right=$\mathtt{Decl\forall I}$]
        {\Psi,a \vdash e \Lto A}
        {\Psi\vdash e\Lto \all A}
    \qquad
    \inferrule*[right=$\mathtt{Decl\forall App}$]
        {\Psi \vdash \tau \quad \Psi\vdash \appInf{[\tau/a]A}{e}{C} }
        {\Psi\vdash \appInf{\all A}{e}{C}}
    \\
    \inferrule*[right=$\mathtt{Decl{\to}I}$]
        {\Psi,x:A \vdash e\Lto B}
        {\Psi\vdash \lam e \Lto A \to B}
    \qquad
    \inferrule*[right=$\mathtt{Decl{\to}I{\To}}$]
        {\Psi\vdash \sigma\to\tau \quad \Psi,x:\sigma \vdash e\Lto \tau}
        {\Psi\vdash \lam e \To \sigma\to\tau}
    \\
    \inferrule*[right=$\mathtt{Decl{\to} E}$]
        {\Psi\vdash e_1\To A \quad \Psi\vdash \appInf{A}{e_2}{C}}
        {\Psi\vdash e_1~e_2 \To C}
    \qquad
    \inferrule*[right=$\mathtt{Decl{\to}App}$]
        {\Psi\vdash e \Lto A}
        {\Psi\vdash \appInf{A \to C}{e}{C}}
    \end{gather*}
\Description{Declarative Typing}
\caption{Declarative Typing}\label{fig:top_decl_typing}
\end{figure}

\paragraph{Declarative Typing}

The declarative typing rules, shown in Figure~\ref{fig:top_decl_typing},
extends DK's higher-rank type system in order to support the top and bottom types.
Rule $\mathtt{Decl\top}$ allows any well-formed expression to check against $\top$.
Rule $\mathtt{Decl{\bot}App}$ returns the $\bot$ type
when a function of $\bot$ type is applied to any argument.
All other rules remain exactly the same as our previous work.

It's worth mentioning that the design of the two new rules
are driven by the subsumption property described in Section~\ref{sec:meta:decl}.
They maintains the property in presence of a more powerful declarative subtyping,
and we will discuss further later in that part.

\setcounter{algRuleCounter}{0}

\section{Backtracking Algorithm}

\subsection{Syntax}

\begin{figure}[ht]
    \begin{gather*}
    \begin{aligned}
        \text{Existential variables}\qquad&\al, \bt\\
        \text{Types}\qquad&A, B, C &::=&\quad 1 \mid \top \mid \bot \mid a \mid \all A \mid A\to B \mid \al\\
        \text{Algorithmic judgment chain}\qquad&\jg &::=&\quad A \le B \mid e\Lto A \mid e\To_{a} \jg \mid \appInfAlg{A}{e}\\
        \text{Algorithmic worklist}\qquad&\Gm &::=&\quad \cdot \mid \Gm, a \mid \Gm, \al \mid \Gm \Vdash \jg
    \end{aligned}
    \end{gather*}
\Description{Algorithmic Syntax}
\caption{Algorithmic Syntax}\label{fig:top_alg_syntax}
\end{figure}

The algorithmic syntax is shown in Figure~\ref{fig:top_alg_syntax}.
Compared with the declarative system, existential variables $\al, \bt$ are used
as placeholders for unsolved mono-types.
The judgment chain $\jg$ and worklist context $\Gm$ are defined in the same way as the ICFP work.

The well-formedness relation is almost the same as that of the ICFP work.
The hole notation is also inherited.

\paragraph{The Solve Notation}
We define a set of auxiliary substitution functions in the form $\{\al := \tau_A\}$
to improve readability of our algorithmic definitions.
Basically it refers to a global substitution when solving an existential variable.

A detailed definition of the notation is shown as follows:
\begin{gather*}
    \begin{aligned}
        \{\al := \tau\}~(\Gm_L, \al, \Gm_R) &= \Gm_L, [\tau/\al]\Gm_R & \tau = 1, \top, \bot \text{ or }a\\
        \{\al := \bt\}~(\Gm_L, \al, \Gm_R) &= \Gm_L, [\bt/\al]\Gm_R & \bt \in \Gm_L\\
        \{\al := \al[1] \to \al[2]\}~(\Gm_L, \al, \Gm_R) &= \Gm_L, \al[1], \al[2], [\al[1] \to \al[2]/\al]\Gm_R\\
    \end{aligned}
\end{gather*}

\subsection{Algorithmic Subtyping}

\begin{figure}[!ht]
    \noindent\framebox{$\Gm\rto \Gm'$} $\Gm$ reduces to $\Gm'$.
    \begin{gather*}
    \begin{aligned}
    \Gm, a &\algrule \Gm\\
    \Gm, \al &\algrule \Gm\\
    \Gm, x:A &\algrule \Gm\\
    % \\
    % \pmb{
    % (\Gm, L \le \al \le U)} &\algrule \Gm \Vdash l_1 \le u_1 \Vdash \ldots \Vdash l_n \le u_m
    % 	\quad \color{blue} \text{Add $nm$ judgments}\\
    \\
    \Gm \Vdash 1\le 1 &\algrule \Gm\\
    \Gm \Vdash a\le a &\algrule \Gm\\
    \Gm \Vdash A_1\to A_2 \le B_1\to B_2 &\algrule \Gm \Vdash A_2 \le B_2 \Vdash B_1\le A_1\\
    \Gm \Vdash \forall a. A\le B &\algrule \Gm, \al \Vdash [\al/a]A\le B\\
    \Gm \Vdash A\le \forall b. B &\algrule \Gm,b \Vdash A\le B\\
    \Gm \Vdash A\le \top &\algrule \Gm\\
    \Gm \Vdash \bot \le B &\algrule \Gm\\
    \\
    \Gm[\al] \Vdash \al\le \al &\algrule \Gm\\
    \\
    % \multispan2{\text{\jimmy{These 2 rules introduce non-determinicity}}}\\
    \Gm[\al] \Vdash A \le \al &\algrule \{\al := \top\}~\Gm[\al]\\
    \Gm[\al] \Vdash \al \le A &\algrule \{\al := \bot\}~\Gm[\al]\\
    \\
    \Gm[\al] \Vdash \al \le A\to B &\algrule
    \{\al := \al[1] \to \al[2]\}~(\Gm[\al] \Vdash \al \le A\to B)\\
    &\qquad\qquad \text{when } \al\notin FV(A \to B)\\
    \Gm[\al] \Vdash A\to B \le \al &\algrule
    \{\al := \al[1] \to \al[2]\}~(\Gm[\al] \Vdash A\to B \le \al)\\
    %\Gm[\al[1], \al[2], L \cup \{\al[1] \to \al[2]\} \le \al \le U] \Vdash A \to B \le \al[1] \to \al[2]\\
    &\qquad\qquad \text{when } \al\notin  FV(A \to B)\\
    \\
    \Gm[a][\bt] \Vdash a \le \bt &\algrule \{\bt := a\}~\Gm[a][\bt]\\
    \Gm[a][\bt] \Vdash \bt \le a &\algrule \{\bt := a\}~\Gm[a][\bt]\\
    \Gm[\bt] \Vdash 1 \le \bt &\algrule \{\bt := 1\}~\Gm[\bt]\\
    \Gm[\bt] \Vdash \bt \le 1 &\algrule \{\bt := 1\}~\Gm[\bt]\\
    \\
    \Gm[\al][\bt] \Vdash \al \le \bt &\algrule \{\bt := \al\}~\Gm[\al][\bt]\\
    \Gm[\al][\bt] \Vdash \bt \le \al &\algrule \{\bt := \al\}~\Gm[\al][\bt]\\
    \end{aligned}
    \end{gather*}
\Description{Algorithmic Garbage Collection and Subtyping}
\caption{Algorithmic Garbage Collection and Subtyping}\label{fig:top_alg_subtyping}
\end{figure}

Figure~\ref{fig:top_alg_subtyping} describes the algorithmic rules for subtyping.
The relation is stated in a small-step ``reduction'' form, i.e. in each step,
the worklist is analysed from the right-hand-side and reduced according to the top judgment.
The overall procedure succeeds iff the worklist eventually reduces to $\cdot$ (the empty worklist).


We categorize them into 7 groups according to their behavior:
\begin{enumerate}
    \item Rules 1-3 are basic garbage collection rules.
        Given that the worklist $\Gm$ is well-formed,
        no reference of a variable should occur before its declaration.
        Therefore removing the declaration in the top position does not break well-formedness.

        An existential variable that is unsolved in the top position indicates
        that it is not constrained,
        thus picking any well-formed mono-type as its solution is acceptable.
        In our algorithmic formalization, we simply drop the existential variable.

    \item Rules 4-10 directly correspond to the declarative subtyping rules.
        With no top-level existential variables,
        there are nothing to guess immediately,
        and thus the algorithm behaves just like the declarative system.

    \item Rule 11 is a base case in the algorithmic system.
        The declarative reflexivity property suggests that any solution is acceptable,
        thus the judgment holds without any constraint.
    
    \item Rules 12-13 are important rules that requires backtracking techniques
        for implementation.
        These rules \emph{overlaps} with all the remaining rules when solving
        an existential variable.
        In other words, they simply try if $\top$ or $\bot$ satisfies the constraints
        in parallel with other possibilities.
    
    \item Rules 14-15 compares an existential variable $\al$ with a function type,
        resulting in solving the $\al$ by $\al[1] \to \al[2]$.
        The freshness condition rules out the possibility
        when there is a cyclic dependency.
        For example, the judgment
        \[\al \le 1 \to \al\]
        is satisfied with either of these solutions to $\al$:
        \[ \bot, 1 \to \bot, \top \to \bot, 1 \to 1 \to \bot, \ldots \]
        However, we argue that comparing $\al$ with a function type
        that contains $\al$ itself is hardly useful in practice,
        and most of the solutions are meaningless.
        Therefore, in our algorithm, only the $\bot$ solution is considered
        with rule 13.
        The condition of rule 14 rejects the judgement for further analysis
        and thus does not produce more solutions.
        This is one source of incompleteness of our algorithm with respect to the declarative specification.
    
    \item Rules 16-19 solve existential variables against a type variable or the unit type.
        For instance, the judgment
        \[\al \le 1\]
        only have two solutions: $\al = 1$ or $\al = \bot$.
        In similar cases, one of the solutions is produced by rule 12 or 13,
        and the other one is given by one of the rules in this group.
        Additional well-formedness check is performed when type variables are encountered;
        a solution to an existential variable must be well-formed in the context
        before the existential variable is defined.
    
    \item Rules 20-21 deals with subtyping judgments
        that compares two different existential variables.
        The only difference between them is the variable order.
        Similar to the type variable case in the previous group,
        existential variables must solve to another one defined earlier.
        With rules 12, 13, 20 and 21, a judgment like
        \[\al \le \bt\]
        could possibly give any of the following solutions:
        \[ \al = \bt ~(\text{or } \bt = \al)
            \text{ or } \al = \bot \text{ or } \bt = \top \]
        Those are good attempts, but unfortunately,
        they does not cover the complete set of possibilities.
        The following example worklist
        \[ \al, \bt \Vdash \bt \le 1 \to 1 \Vdash \al \le \bt \]
        has a solution $\al = 1 \to \top, \bt = 1 \to 1$ missed by our algorithm.
        Similar situations happen when the judgments are specifically ordered;
        if $\bt \le 1 \to 1$ is the top-most judgment,
        the algorithm will not miss this solution.

        Although such treatment for existential variable solving is incomplete in theory,
        a large number of practical unification is simply equality,
        and the algorithm completely handles these programs.
        Other programs that exploit complex guessing involving subtyping,
        the programmer may put annotation when the type inference algorithm
        does not find the optimal solution.
\end{enumerate}


\subsection{Algorithmic Typing}

\begin{figure}[!ht]
\noindent\framebox{$\Gm\rto \Gm'$} $\Gm$ reduces to $\Gm'$ (continued).
\begin{gather*}
\begin{aligned}
    \Gm \Vdash e \Lto B &\algrule \Gm \Vdash e\To_a a\le B \quad
    \text{when } e \neq \lam e' \text{ and } B \neq \all B'\\
    \Gm \Vdash e\Lto \all A &\algrule \Gm,a \Vdash e\Lto A\\
    \Gm \Vdash \lam e \Lto A\to B &\algrule \Gm, x:A  \Vdash e \Lto B\\
    \Gm[\al] \Vdash \lam e \Lto \al &\algrule \{\al := \al[1]\to \al[2]\}~\Gm, x:\al[1] \Vdash e \Lto \al[2]\\
    \Gm \Vdash e \Lto \top &\algrule \Gm\\
    \Gm[\al] \Vdash e \Lto \al &\algrule \{\al := \top\}~\Gm[\al]
    % \quad\text{\jimmy{Additional}}
    \\[3mm]
    \Gm \Vdash x\To_a \jg &\algrule \Gm \Vdash [A/a] \jg \quad \text{when } (x:A)\in \Gm\\
    \Gm \Vdash (e:A)\To_a \jg &\algrule \Gm \Vdash [A/a]\jg \Vdash e \Lto A\\
    \Gm \Vdash ()\To_a \jg &\algrule \Gm \Vdash [1/a]\jg\\
    \Gm \Vdash \lam e \To_a \jg &\algrule
    \Gm,\al,\bt \Vdash [\al\to\bt/a]\jg, x:\al \Vdash e\Lto \bt\\
    \Gm \Vdash e_1\ e_2 \To_a \jg &\algrule \Gm \Vdash e_1\To_b (\appInfAlg{b}{e_2})
    \\[3mm]
    \Gm \Vdash \appInfAlg{\all A}{e} &\algrule \Gm,\al \Vdash \appInfAlg{[\al/a]A}{e}\\
    \Gm \Vdash \appInfAlg{A\to C}{e} &\algrule \Gm \Vdash [C/a]\jg \Vdash e \Lto A\\
    \Gm \Vdash \appInfAlg{\bot}{e} &\algrule \Gm \Vdash [\bot/a]\jg\\
    \Gm[\al] \Vdash \appInfAlg{\al}{e} &\algrule
        \{\al := \al[1]\to \al[2]\}~\Gm \Vdash \appInfAlg{\al[1]\to\al[2]}{e}\\
    \Gm[\al] \Vdash \appInfAlg{\al}{e} &\algrule
        \{\al := \bot\}~\Gm[\al] \Vdash [\bot/a]\jg
\end{aligned}
\end{gather*}
\Description{Algorithmic Typing}
\caption{Algorithmic Typing}\label{fig:top_alg_typing}
\end{figure}

The algorithmic typing rules split into three groups,
according to the category of the top-most judgment.

\begin{enumerate}
    \item Checking mode. Rules 22-27 reduce top-level checking judgments.
            Rules 22, 23, 24 and 26 directly reflects how the declarative system behaves.
            Rule 25 splits $\al$ into $\al[1] \to \al[2]$ to mimic the same logic as rule 24,
            since a lambda expression must be of an function type.
            Rule 27 is another backtracking rule, which overlaps with all other checking rules.
            Solving $\al$ to $\top$ in such case reflects
            the declarative rule $\mathtt{Decl{\top}}$ when the unknown type is $\top$.
            Furthermore, we eliminate the algorithmic counterpart of declarative rule
            $\mathtt{Decl1I}$, because a combination of Rules 22 and 30 already
            accepts the judgment $() \Lto 1$.
    
    \item Inference mode. Rules 28-32 reduce inference judgments.
            Like our previous work, encoding of the return type is by
            an explicit substitution on the binder of a judgment chain.
            Rules 28, 29, 30 and 32 corresponds to the declarative system straightforwardly.
            Rule 31 guesses an unannotated lambda with a mono function type $\al \to \bt$.
            Writing in a slightly different way may help improve readability:
            \[ \Gm \Vdash \lam e \To_a \jg \rrule{31'}
                \Gm, \al, \bt \Vdash [\al \to \bt / a]\jg \Vdash \lam e \Lto \al \to \bt \]
            Rule 32 illustrates how the judgment chain works, with a continuation-passing-style
            encoding of the type inference task.
    
    \item Application inference mode. Rules 33-37 reduce application inference judgments.
            Each of these judgments accepts an input function type and an argument expression
            and produces the expected return type.
            Rules 33, 34 and 35 are direct translation from the declarative rules.
            Rule 33, specifically, enables implicit parametric polymorphism via
            existential variable solving.
            Rules 36 and 37 deal with cases where a single existential variable
            $\al$ as a function type.
            Rule 36 splits $\al$ into a function unknown type $\al[1] \to \al[2]$.
            Rule 37 tries the solution $\al = \bot$ and returns the $\bot$ type.
            Both of the rules are not so useful in reality,
            since it is derived from a parametric function type like $\all a$,
            which behaves like the the $\bot$ type.


\end{enumerate}



\section{Metatheory}

\subsection{Declarative Properties}\label{sec:meta:decl}

An important desired property for a type system is \emph{checking subsumption},
which basically says that any expression can
check against any super type of its actual type.
Since our bidirectional type system defines the checking mode, inference mode and
application inference mode mutually,
we formalize the generalized \emph{typing subsumption}.

\begin{definition}[Worklist Subtyping]
    Worklist subtyping compares the type of variables bound in the worklist.
    $\Gm <: \Gm'$ iff each binding in $\Gm$ is converted to one with a super type.
    \begin{gather*}
        \inferrule*[right=$\mathtt{<:nil}$]
            {~}{\cdot <: \cdot}
        \qquad
        \inferrule*[right=$\mathtt{<:ty}$]
            {\Gm <: \Gm'}
            {\Gm, a <: \Gm', a}
        \\
        \inferrule*[right=$\mathtt{<:of}$]
            {\Gm' \vdash A \le B \\ \Gm <: \Gm'}
            {\Gm, x:A <: \Gm', x:B}
        \qquad
        \inferrule*[right=$\mathtt{<:\omega}$]
            {\Gm <: \Gm'}
            {\Gm \Vdash \jg <: \Gm' \Vdash \jg}
    \end{gather*}
\end{definition}

A basic property of worklist subtyping is that they acts similarly when viewed as contexts.
\begin{lemma}[Worklist Subtyping Equivalence]
    Given $\Gm <: \Gm'$, $\Gm \vdash A \le B \Longleftrightarrow \Gm' \vdash A \le B$.
\end{lemma}

\begin{lemma}[Typing Subsumption]
    Given $\Gm <: \Gm'$,
    \begin{enumerate}[1)]
        \item If $\Gm' \vdash e \Lto A$ and $\Gm' \vdash A \le B$, then $\Gm \vdash e \Lto B$;
        \item If $\Gm' \vdash e \To A$, then $\exists B$ s.t. $\Gm' \vdash B \le A$ and $\Gm \vdash e \To B$.
        \item If $\Gm' \vdash \appInf{C}{e}{A}$ and $\Gm' \vdash D \le C$, then
            $\exists B$ s.t. $\Gm' \vdash B \le A$ and $\Gm \vdash \appInf{D}{e}{B}$.
    \end{enumerate}
\end{lemma}

\begin{proof}
    By induction on the following size measure (lexicographical order on a 3-tuple):
    \begin{itemize}
        \item Checking ($e \Lto A$): $\langle |e|, 1, |A|_\forall + |B|_\forall \rangle$
        \item Inference ($e \To A$): $\langle |e|, 0, 0 \rangle$
        \item Application inference ($\appInf{A}{e}{C}$): $\langle |e|, 2, |C|_\forall + |D|_\forall \rangle$
    \end{itemize}
    Most of the cases are straightforward.
    When rule $\mathtt{{\le}\forall L}$ is applied for the subtyping predicate
    like $\Gm' \vdash A \le B$,
    a mono-type substitution is performed on $\all A$,
    resulting in $[\tau/a]A$.
    Since $\tau$ is a mono-type, the result type reduces the number of $\forall$'s,
    and thus reduces the size measure.
\end{proof}

The two new declarative rules $\mathtt{Decl\top}$ and $\mathtt{Decl{\bot}App}$ are
discovered through it and verified against it.
To the best of the authors' knowledge,
they are the minimal set of rules that keep the lemma hold.


\paragraph{Subtyping Transitivity}

The transitivity lemma for declarative subtyping is a commonly expected property.
The proof depends on the following subtyping derivation size relation and an auxiliary lemma.

\begin{definition}[Subtyping Derivation Size]
    \begin{gather*}
        \begin{aligned}
            |1 \le 1| &= 0\\
            |a \le a| &= 0\\
            |A \le \top| &= 0\\
            |\bot \le B| &= 0\\
            |A_1 \to A_2 \le B_1 \to B_2| &= |B_1 \le A_1| + |A_2 \le B_2| + 1\\
            |\all A \le B| &= |[\tau/a]A \le B| + 1\\
            |A \le \all B| &= |A \le B| + 1
        \end{aligned}
    \end{gather*}
\end{definition}

\begin{lemma}[Subtyping Substiting Mono-type]
    If $\Psi \vdash \tau$ and $\Psi, a, \Psi_R \vdash A \le B$, then
    $\Psi, [\tau/a]\Psi_R \vdash [\tau/a]A \le [\tau/a]B$.
\end{lemma}

\begin{proof}
    A routine induction on the subtyping relation $\Psi, a, \Psi_R \vdash A \le B$
    finishes the proof.
\end{proof}

\begin{corollary}[Subtyping Substiting Type Var with a Mono-type]
    \label{cor:subtyping_subst_mono}
    If $\Psi \vdash \tau$ and $\Psi, a \vdash A \le B$, then
    $\Psi \vdash [\tau/a]A \le [\tau/a]B$.
\end{corollary}

\begin{lemma}[Subtyping Transitivity]
    If $\Psi \vdash A \le B$ and $\Psi \vdash B \le C$ then
    $\Psi \vdash A \le C$.
\end{lemma}

\begin{proof}
    Induction on $\langle |B|_\forall, |A \le B| + |B \le C| \rangle$.
    Most cases preserve the first element of the size measures $|B|_\forall$,
    and are relatively easy to prove.
    The difficult case is when $B$ is a polymorphic type,
    when the conditions are $\Psi \vdash A \le \all B$ and $\Psi \vdash \all B \le C$.
    They are derived through rules $\mathtt{{\le}\forall L}$ and
    $\mathtt{{\le}\forall R}$, respectively.
    Therefore, we have $\Psi, a \vdash A \le B$ and $\Psi \vdash [\tau/a] B \le C$.
    To exploit the induction hypothesis, the contexts should be unified.
    By Corollary~\ref{cor:subtyping_subst_mono}, $\Psi \vdash A \le [\tau/a]B$.
    Notice that the freshness condition is implicit for rule $\mathtt{{\le}\forall L}$.
    Clearly, $|[\tau/a]B|_\forall < |\all B|_\forall$, i.e. the first size measure decreases.
    By induction hypothesis we get $\Psi \vdash A \le C$ and finishes this case.
\end{proof}

\subsection{Soundness}

Our algorithm is sound with respect to the declarative system.
For any worklist $\Gm$ that reduces successfully,
there is a valid instantiation $\Om$ that transfers all judgments
to the declarative system.
\begin{theorem}[Soundness]
If \emph{wf }$\Gm$ and $\Gm \redto \nil$,
then there exists $\Om$ s.t. $\Gm\sto\Om$ and $\Om\redto\nil$.
\end{theorem}

\subsection{Partial Completeness of Subtyping: Rank-1 Restriction}

The algorithm is incomplete due to the subtyping rules 14, 15, 20 and 21.
However, subtyping is complete with respect to the declarative system in rank-1 setting.

\paragraph{Declarative Rank-1 Restriction}

Rank-1 types are also named type schemes in Hindley-Milner type system.
$$\begin{aligned}
    \text{Declarative Type Schemes}\qquad&\sigma &::=&\quad \all \sigma \mid \tau\\
\end{aligned}$$
In other words, the universal quantifiers only appear in the top level
of all polymorphic types.

For declarative subtyping, a judgment must be of form $\sigma_1 \le \sigma_2$.

\subsection{Algorithmic Rank-1 Restriction (Partial Completeness)}

The algorithmic mono-types and type schemes are defined as following:
$$\begin{aligned}
    \text{Algorithmic Mono-types}\qquad&\tau_A &::=&\quad
        1 \mid \top \mid \bot \mid a \mid A\to B \mid \al\\
    \text{Algorithmic Type Schemes}\qquad&\sigma_A &::=&\quad \all \sigma_A \mid \tau_A\\
\end{aligned}$$

Starting from the declarative judgment $\sigma_1 \le \sigma_2$,
the algorithmic derivation might involve different other kinds of judgments.
The following derivation, as an example, shows how a rank-1 judgment derives.

$$\begin{aligned}
           & \cdot \Vdash \all a \to a \le \all[b] (b \to b) \to (b \to b)\\
    \rrule{8} & b \Vdash \all a \to a \le (b \to b) \to (b \to b)\\
    \rrule{7} & b, \al \Vdash \al \to \al \le (b \to b) \to (b \to b)\\
    \rrule{6} & b, \al \Vdash \al \le b \to b \Vdash b \to b \le \al\\
    \rrule{} & \cdots
\end{aligned}$$

In this derivation, we begin from a judgment of the form $\sigma \le \sigma$.
After rule 8 is applied, the judgment becomes $\sigma \le \tau$,
since the right-hand-side polymorphic type is reduced to a declarative mono-type.
Then, rule 7 introduces existential variables to the left-hand-side,
resulting in a judgment like $\tau_A \le \tau$,
or $\sigma_A \le \tau$ in a more general case.
Finally, rule 6 breaks a judgment between functions into two sub-judgments,
which swaps the positions of the argument types
and creates a judgment like $\tau \le \tau_A$.
Notice that $\sigma_A$ is not possible to occur to the right
because the function type may not contain any polymorphic types as its argument type.

\jimmy{TODO the detailed analysis, perhaps a graph?}
After a detailed analysis on the judgments derivations,
we found that the only possible judgments that a rank-1 declarative subtyping judgment
might step to belong to the following two categories:
$$\sigma_A \le \sigma \quad\text{or}\quad \tau \le \sigma_A$$

An interesting observation is that $\al \le \bt$ does not belong to either category,
neither does $\al \le A \to B$ when $\al \in \text{FV}(A \to B)$.
Therefore, in the rank-1 setting, both cases of incompleteness never occur,
and our algorithm is complete.

\begin{theorem}[Completeness of Rank-1 Subtyping]
    Given $\Om \vdash \sigma_1 \le \sigma_2$,
    \begin{itemize}
        \item If $\Gm \Vdash \sigma_A \le \sigma \sto \Om \Vdash \sigma_1 \le \sigma_2$
            \\then $\Gm \Vdash \sigma_A \le \sigma \redto \nil$;
        \item If $\Gm \Vdash \tau \le \sigma_A \sto \Om \Vdash \sigma_1 \le \sigma_2$
            \\then $\Gm \Vdash \tau \le \sigma_A \redto \nil$.
    \end{itemize}
\end{theorem}

\subsection{Termination}

The measure used in ICFP no longer works because subtyping judgments like
$$\al \le \bot \to \top$$
cause $\al$ to split into $\al[1] \to \al[2]$, without solving any part of it,
resulting in an increased number of existential variables
and possibly increased complexity of the worklist through the size-increasing substitution
$\{\al := \al[1] \to \al[2]\}$.

We have performed a large set of tests on generated subtyping judgments
that are consist of algorithmic mono types,
and all judgements terminated within a reasonable number of derivation depth.
Unfortunately, we have not yet find any formal proof for the termination statement.

\subsection{Formalization in the Abella Proof Assistant}


\section{Discussion}
\subsection{Lazy Substitution and Non-terminating Loops}

One major source of incompleteness comes from rule 20 and 21,
where two different existential variables are compared.
A natural idea is to delay the solving procedure until all the corresponding
constraints are collected.
Constraint collection can be implemented by the following new worklist definition,
where the existential variables also come with a set of upper bounds
and a set of lower bounds. Both of the bounds are consist of algorithmic mono-types.

\begin{gather*}
    \begin{aligned}
        \text{Algorithmic worklist}\qquad&\Gm &::=&\quad \cdot \mid \Gm, a \mid \Gm, \overline{\tau_A} \le \al \le \overline{\tau_A} \mid \Gm \Vdash \jg
    \end{aligned}
\end{gather*}

In presence of the bound collections, the algorithm behaves slightly differently
on variable solving rules.
For example, rules 20 and 21 add the corresponding existential variable
as part of a bound rather than performing a global substitution.

\begin{gather*}
    \begin{aligned}
\Gm[\al][L \le \bt \le U] \Vdash \al \le \bt &\rrule{20'}
    \Gm[\al][L \cup \{\al\} \le \bt \le U]\\
\Gm[\al][L \le \bt \le U] \Vdash \bt \le \al &\rrule{21'}
    \Gm[\al][L \le \bt \le U \cup \{\al\}]\\
    \end{aligned}
\end{gather*}

The change of existential variable declaration also result in the change of
the algorithmic rule on existential variable garbage collection.
When $\al$ is to be recycled, we need to propagate the subtyping check to
the bounds: any type that is a subtype of $\al$ should be subtype of
any super type of $\al$, according to the transitivity of subtyping.

\begin{gather*}
    \begin{aligned}
\Gm, \{l_i\}^n \le \al \le \{u_j\}^m &\rrule{2'}
    \Gm \Vdash_{1 \le i \le n, 1 \le j \le m} l_i \le u_j\\
    \end{aligned}
\end{gather*}

Luckily, such check is sufficient. In other words,
we can always find a proper solution for $\al$ if any lower bound
is subtype of any upper bound.

This new approach fixes the incompleteness caused by rules 20 and 21,
however, the algorithm might loop forever due to the
(new version of) instantiation rules 14 and 15.
For example, the following derivation results in infinite instantiations:

\begin{gather*}
    \begin{aligned}
     & \al, \bt \Vdash \al \le 1 \to \bt \Vdash \bt \le 1 \to \al\\
\rto~& \al, \bt[1], \bt[2], \{\} \le \bt \le \{\bt[1] \to \bt[2]\}
        \Vdash \al \le 1 \to \bt \Vdash \bt[1] \to \bt[2] \le 1 \to \al\\
\rto~& \cdots\\
\rto~& \al, \{1\} \le \bt[1] \le \{\}, \{\} \le \bt[2] \le \{\al\},
        \{\} \le \bt \le \{\bt[1] \to \bt[2]\}
        \Vdash \al \le 1 \to \bt\\
    \end{aligned}
\end{gather*}

\jimmy{Not sure whether this discussion is valueable;
in fact the example is hard to demonstrate the infinite loop
(not straightforward to understand)}
